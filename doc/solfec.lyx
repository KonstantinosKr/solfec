#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass book
\use_default_options true
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 4cm
\rightmargin 2cm
\bottommargin 4cm
\headheight 2cm
\headsep 1cm
\footskip 2cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Solfec User Manual
\end_layout

\begin_layout Author
Tomasz Koziara
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Introduction"

\end_inset

Introduction
\end_layout

\begin_layout Abstract
Solfec is a computational code aimed at simulation of multi-body systems
 with constraints.
 It implements an instance of the Contact Dynamics (CD) method by Moreau
 
\begin_inset CommandInset citation
LatexCommand cite
key "Moreau01"

\end_inset

 and Jean 
\begin_inset CommandInset citation
LatexCommand cite
key "Jean01"

\end_inset

, hence the constraints are handled implicitly.
 One of the main goals of the software is to provide a user friendly platform
 for testing formulations and solution methods for the (dynamic) frictional
 contact problem.
 It is also meant to serve as a development platform for other aspects of
 time-stepping methods (e.g.
 contact detection, time integration).
 The code implements several kinematic models (rigid, pseudo-rigid, finite
 element), few contact detection algorithms, several time integrators and
 a couple of constraint solvers (e.g.
 penalty, Gauss-Seidel).
 A distributed memory and a serial versions of the code are available.
 Solfec is an open-source software and can be downloaded from 
\begin_inset CommandInset href
LatexCommand href
target "http://code.google.com/p/solfec"

\end_inset

.
\end_layout

\begin_layout Section*
Basics
\end_layout

\begin_layout Standard
It will be useful to introduce some basic notions here.
 Let us have a look at a figure below
\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/intro.eps
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset

There are four bodies in the figure.
 Placement of each point of every body is determined by a configuration
 
\begin_inset Formula $\mathbf{q}_{i}$
\end_inset

.
 Velocity of each point of every body is determined by a velocity 
\begin_inset Formula $\mathbf{u}_{i}$
\end_inset

.
 Let 
\begin_inset Formula $\mathbf{q}$
\end_inset

 and 
\begin_inset Formula $\mathbf{u}$
\end_inset

 collect configurations and velocities of all bodies.
 If the time history of velocity is known, the configuration time history
 can be computed as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{q}\left(t\right)=\mathbf{q}\left(0\right)+\int_{0}^{t}\mathbf{u}dt\label{eq:q-update}\end{equation}

\end_inset

The velocity is determined by integrating Newton's law
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{u}\left(t\right)=\mathbf{u}\left(0\right)+\mathbf{M}^{-1}\int_{0}^{t}\left(\mathbf{f}+\mathbf{H}^{T}\mathbf{R}\right)dt\label{eq:u-update}\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{M}$
\end_inset

 is an inertia operator (assumed constant here), 
\begin_inset Formula $\mathbf{f}$
\end_inset

 is an out of balance force, 
\begin_inset Formula $\mathbf{H}$
\end_inset

 is a linear operator, and 
\begin_inset Formula $\mathbf{R}$
\end_inset

 collects some point forces 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

.
 While integrating the motion of bodies, we keep track of a number of local
 coordinate systems (local frames).
 There are four of them in the above figure.
 Each local frame is related to a pair of points, usually belonging to two
 distinct bodies.
 An observer embedded at a local frame calculates the local relative velocity
 
\begin_inset Formula $\mathbf{U}_{\alpha}$
\end_inset

 of one of the points, viewed from the perspective of the other point.
 Let 
\begin_inset Formula $\mathbf{U}$
\end_inset

 collect all local velocities.
 Then, we can find a linear transformation 
\begin_inset Formula $\mathbf{H}$
\end_inset

, such that
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{U}=\mathbf{H}\mathbf{u}\label{eq:UHu}\end{equation}

\end_inset

In our case local frames correspond to 
\emph on
constraints
\emph default
.
 We influence the local relative velocities by applying local forces 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

.
 This can be collectively described by an implicit relation
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{C}\left(\mathbf{U},\mathbf{R}\right)=\mathbf{0}\label{eq:CUR}\end{equation}

\end_inset

Hence, in order to integrate equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:q-update"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:u-update"

\end_inset

), at every instant of time we need to solve the implicit relation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:CUR"

\end_inset

).
 Here is an example of a numerical approximation of such procedure
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{q}^{t+\frac{h}{2}}=\mathbf{q}^{t}+\frac{h}{2}\mathbf{u}^{t}\label{eq:q(t+h/2)}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{u}^{t+h}=\mathbf{u}^{t}+\mathbf{M}^{-1}h\mathbf{f}^{t+\frac{h}{2}}+\mathbf{M}^{-1}\mathbf{H}^{T}\mathbf{R}\label{eq:u(t+h)}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{q}^{t+h}=\mathbf{q}^{t+\frac{h}{2}}+\frac{h}{2}\mathbf{u}^{t+h}\label{eq:q(t+h)}\end{equation}

\end_inset

where 
\begin_inset Formula $h$
\end_inset

 is a discrete time step.
 As the time step 
\begin_inset Formula $h$
\end_inset

 does not appear by 
\begin_inset Formula $\mathbf{M}^{-1}\mathbf{H}^{T}\mathbf{R}$
\end_inset

, 
\begin_inset Formula $\mathbf{R}$
\end_inset

 should now be interpreted as an impulse (an 
\emph on
integral
\emph default
 of reactions over 
\begin_inset Formula $\left[t,t+h\right]$
\end_inset

).
 At a start we have
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{q}^{0}\mbox{ and }\mathbf{u}^{0}\mbox{ as prescribed initial conditions.}\label{eq:ini}\end{equation}

\end_inset

The out of balance force
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{f}^{t+\frac{h}{2}}=\mathbf{f}\left(\mathbf{q}^{t+\frac{h}{2}},t+\frac{h}{2}\right)\end{equation}

\end_inset

incorporates both internal and external forces.
 The symmetric and positive-definite inertia operator
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{M}=\mathbf{M}\left(\mathbf{q}^{0}\right)\end{equation}

\end_inset

is computed once.
 The linear operator
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{H}=\mathbf{H}\left(\mathbf{q}^{t+\frac{h}{2}}\right)\end{equation}

\end_inset

is computed at every time step.
 The number of rows of 
\begin_inset Formula $\mathbf{H}$
\end_inset

 depends on the number of constraints, while its rank is related to their
 linear independence.
 We then compute
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{B}=\mathbf{H}\left(\mathbf{u}^{t}+\mathbf{M}^{-1}h\mathbf{f}^{t+\frac{h}{2}}\right)\end{equation}

\end_inset

and
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{W}=\mathbf{H}\mathbf{M}^{-1}\mathbf{H}^{T}\label{eq:W}\end{equation}

\end_inset

which is symmetric and semi-positive definite.
 The linear transformation
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{U}=\mathbf{B}+\mathbf{W}\mathbf{R}\label{eq:locdyn}\end{equation}

\end_inset

maps constraint reactions 
\begin_inset Formula $\mathbf{R}$
\end_inset

 into local relative velocities 
\begin_inset Formula $\mathbf{U}=\mathbf{H}\mathbf{u}^{t+h}$
\end_inset

 at time 
\begin_inset Formula $t+h$
\end_inset

.
 Relation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:locdyn"

\end_inset

) will be here referred to as the 
\emph on
local dynamics
\emph default
.
 Finally
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{R}\mbox{ is such that }\mathbf{C}\left(\mathbf{U},\mathbf{R}\right)=\mathbf{C}\left(\mathbf{B}+\mathbf{W}\mathbf{R},\mathbf{R}\right)=\mathbf{C}\left(\mathbf{R}\right)=\mathbf{0}\label{eq:constraints}\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{C}$
\end_inset

 is a nonlinear and usually nonsmooth operator.
 A basic Contact Dynamics algorithm can be summarised as follows:
\end_layout

\begin_layout Enumerate
Perform first half-step 
\begin_inset Formula $\mathbf{q}^{t+\frac{h}{2}}=\mathbf{q}^{t}+\frac{h}{2}\mathbf{u}^{t}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Update existing constraints and detect new contact points.
\end_layout

\begin_layout Enumerate
Compute 
\begin_inset Formula $\mathbf{W}$
\end_inset

, 
\begin_inset Formula $\mathbf{B}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Solve 
\begin_inset Formula $\mathbf{C}\left(\mathbf{R}\right)=\mathbf{0}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Update velocity 
\begin_inset Formula $\mathbf{u}^{t+h}=\mathbf{u}^{t}+\mathbf{M}^{-1}h\mathbf{f}^{t+\frac{h}{2}}+\mathbf{M}^{-1}\mathbf{H}^{T}\mathbf{R}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Perform second half-step 
\begin_inset Formula $\mathbf{q}^{t+h}=\mathbf{q}^{t+\frac{h}{2}}+\frac{h}{2}\mathbf{u}^{t+h}$
\end_inset

.
\end_layout

\begin_layout Standard
It should be stressed that the above presentation exemplifies only a particular
 instance of Contact Dynamics.
 Let us refer the reader to 
\begin_inset CommandInset citation
LatexCommand cite
key "MoreauBook,Moreau1999b,BrogliatoBook,Moreau01,Jean01,Glocker2001book,Acary2008,LeineStability,Studer2009book,Koziara2008PhD"

\end_inset

 for more details.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Installation"

\end_inset

Installation
\end_layout

\begin_layout Standard
Although there will be perpetual releases of Solfec with some fixed version
 numbers, it is best to use the most recent development version of the code.
 This is because Solfec is in an active 
\begin_inset Quotes eld
\end_inset

beta
\begin_inset Quotes erd
\end_inset

 stage of development for the moment.
 In order to download the most recent sources, you first need to install
 
\emph on
Mercurial
\emph default
.
 Have a look at 
\begin_inset CommandInset href
LatexCommand href
target "http://mercurial.selenic.com/"

\end_inset

 for instructions.
 Once the 
\emph on
hg
\emph default
 command is available on your command line, type
\end_layout

\begin_layout LyX-Code
hg clone https://solfec.googlecode.com/hg/ solfec 
\end_layout

\begin_layout Standard
This will create the directory 
\emph on
solfec
\emph default
 in your current directory.
 The next thing you need is an ANSI C development environment at your command
 line.
 Users of UNIX-like systems (Linux, FreeBSD, Mac OS X, etc.) are in privileged
 position here.
 Windows users can cope by installing Cygwin from 
\begin_inset CommandInset href
LatexCommand href
target "http://www.cygwin.com/"

\end_inset

 or Mingw from 
\begin_inset CommandInset href
LatexCommand href
target "http://www.mingw.org/"

\end_inset

.
\end_layout

\begin_layout Standard
Solfec is written in C and it uses a simple makefile to get compiled.
 The file 
\emph on
solfec/Config.mak
\emph default
 needs to be modified on a new machine so that to set up library paths and
 compilation flags.
 Let us have a look at the file 
\emph on
solfec/Config.mak
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Operating System (WIN32, SOLARIS, LINUX, AIX, IRIX, OSX)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
OS = OSX 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Specify C compiler here
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
CC = cc
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Debug or optimized version switch (yes/no)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
DEBUG = yes
\end_layout

\begin_layout LyX-Code
PROFILE = no
\end_layout

\begin_layout LyX-Code
MEMDEBUG = no
\end_layout

\begin_layout LyX-Code
GEOMDEBUG = no
\end_layout

\begin_layout LyX-Code
PARDEBUG = no
\end_layout

\begin_layout LyX-Code
NOTHROW = no
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# TIMERS (enable/disable detailed solver timings)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
TIMERS = yes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# POSIX
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
POSIX = yes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# XDR
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
XDR = no
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
XDRINC =
\end_layout

\begin_layout LyX-Code
XDRLIB =
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# BLAS
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
BLAS = -L/usr/lib -lblas
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# LAPACK
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
LAPACK = -L/usr/lib -llapack
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Python
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
PYTHON = -I/usr/include/python2.5
\end_layout

\begin_layout LyX-Code
PYTHONLIB = -L/usr/lib -lpython2.5
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# OpenGL (yes/no)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
OPENGL = yes
\end_layout

\begin_layout LyX-Code
GLINC =
\end_layout

\begin_layout LyX-Code
GLLIB = -framework GLUT -framework OpenGL
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# VBO (OPENGL == yes)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
VBO = yes
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# MPI (yes/no)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
MPI = yes
\end_layout

\begin_layout LyX-Code
MPICC = mpicc
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code
# Zoltan (MPI == yes)
\end_layout

\begin_layout LyX-Code
#
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
ZOLTANINC = -I/Users/tomek/Devel/lib/zoltan/include
\end_layout

\begin_layout LyX-Code
ZOLTANLIB = -L/Users/tomek/Devel/lib/zoltan/lib -lzoltan
\end_layout

\begin_layout Standard
The above configuration works on Mac OS X.
 Examples for Linux and Cygwin can be found in 
\emph on
solfec/cfg
\emph default
.
 What you need is:
\end_layout

\begin_layout Itemize
A 
\series bold
C
\series default
 compiler
\end_layout

\begin_layout Itemize

\series bold
XDR
\series default
 (standard part of RPC on all Unix-like systems; on MinGW you will need
 
\begin_inset CommandInset href
LatexCommand href
name "PortableXDR version 4.9.1"
target "http://people.redhat.com/~rjones/portablexdr/"

\end_inset

 with this 
\begin_inset CommandInset href
LatexCommand href
name "patch"
target "http://wiki.solfec.googlecode.com/hg/xdr_float.patch"

\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
BLAS
\series default
 and 
\series bold
LAPACK
\series default
 libraries (standard on most systems; available from 
\begin_inset CommandInset href
LatexCommand href
target "http://www.netlib.org/lapack/"

\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
Python
\series default
 together with development files and libraries
\end_layout

\begin_layout Itemize

\series bold
OpenGL
\series default
 libraries and developments files
\end_layout

\begin_layout Itemize

\series bold
VBO
\series default
 (Vertex Buffer Object extension of OpenGL for faster rendering; optional)
\end_layout

\begin_layout Itemize

\series bold
MPI
\series default
 libraries and development files
\end_layout

\begin_layout Itemize

\series bold
Zoltan
\series default
 load balancing library
\end_layout

\begin_layout Standard
All of them, but Zoltan, should be already installed on your system or are
 quite easy to install otherwise.
 Zoltan on the other hand can be obtained from 
\begin_inset CommandInset href
LatexCommand href
target "http://www.cs.sandia.gov/Zoltan/"

\end_inset

.
 In case of troubles - use the Solfec mailing list at 
\begin_inset CommandInset href
LatexCommand href
target "http://groups.google.com/group/solfec"

\end_inset

.
 
\end_layout

\begin_layout Standard
Use 
\begin_inset Quotes eld
\end_inset

DEBUG = yes
\begin_inset Quotes erd
\end_inset

 most of the time (this is slower but outputs more information in case you
 would encounter a bug), but for 
\begin_inset Quotes eld
\end_inset

proper computations
\begin_inset Quotes erd
\end_inset

 compile optimized code by selecting 
\begin_inset Quotes eld
\end_inset

DEBUG = no
\begin_inset Quotes erd
\end_inset

.
 After you edit the 
\emph on
Config.mak
\emph default
 file, the first compilation should look like
\end_layout

\begin_layout LyX-Code
cd 
\emph on
solfec
\end_layout

\begin_layout LyX-Code
make all
\end_layout

\begin_layout Standard
This will create files 
\emph on
solfec/solfec
\emph default
 and 
\emph on
solec/solfec-mpi
\emph default
, that is the serial and the parallel versions of the code.
 For every subsequent code update and compilation you will like to do the
 following
\end_layout

\begin_layout Itemize
Back up your 
\emph on
Config.mak
\emph default
 file.
 For example
\end_layout

\begin_layout LyX-Code
cd solfec
\end_layout

\begin_layout LyX-Code
cp Config.mak ..
\end_layout

\begin_layout Itemize
Now update the sources
\end_layout

\begin_layout LyX-Code
hg pull
\end_layout

\begin_layout LyX-Code
hg update -C
\end_layout

\begin_layout Itemize
Recover your 
\emph on
Config.mak
\emph default
 file
\end_layout

\begin_layout LyX-Code
cp ../Congig.mak ./
\end_layout

\begin_layout Itemize
And finally compile again
\end_layout

\begin_layout LyX-Code
make clean
\end_layout

\begin_layout LyX-Code
make all
\end_layout

\begin_layout Standard
The 
\emph on
solfec/inp
\emph default
 directory contains example input files.
 If you haven't used the 
\begin_inset Quotes eld
\end_inset

POSIX = yes
\begin_inset Quotes erd
\end_inset

 flag, you will need to create all output directories yourself.
 Normally though this should be done automatically.
 If you wish to move 
\emph on
solfec
\emph default
, 
\emph on
solfec-mpi
\emph default
 and the input files to some other directory - you need to do it by hand.
 I recommend setting the PATH variable so that the 
\emph on
solfec
\emph default
 directory is included.
 This way some computations not related to development can be done 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Running-Solfec"

\end_inset

Running Solfec
\end_layout

\begin_layout Standard
Solfec is a command line program.
 It can be run sequentially (command: 
\emph on
solfec
\emph default
) or in parallel using the MPI runtime environment (command: 
\emph on
solfec-mpi
\emph default
).
 Running it without parameters
\end_layout

\begin_layout LyX-Code
./solfec
\end_layout

\begin_layout Standard
results in the hint
\end_layout

\begin_layout LyX-Code
SYNOPSIS: solfec [-v] [-w] [-g WIDTHxHEIGHT] [-s sub-directory] path
\end_layout

\begin_layout Standard
The 
\emph on
-v
\emph default
 switch opens the interactive graphical viewer (cf.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Solfec-viewer"

\end_inset

).
 In this mode the user can view the geometrical mode, run or step through
 analysis, and view results.
 The right mouse click on the viewer window expands the menu.
 The 
\emph on
-w
\emph default
 switch forces the computation (write) mode: if some results are present,
 they will be overwritten.
 The 
\emph on
-g
\emph default
 switch allows to specify the initial width and height of the viewer window
 (512 by default).
 The 
\emph on
-s
\emph default
 switch allows to output or read the results from a sub-directory.
 This option is useful when one wishes to output results of similar analyses
 to different sub-directories of a common root directory specified when
 creating a SOLFEC object (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SOLFEC"

\end_inset

).
 For example, the bellow commands would run a parallel example and output
 the results into different sub-directories denoted by the number of processors
 involved in the analysis
\end_layout

\begin_layout LyX-Code
mpirun -np 4 solfec-mpi -s 4 inp/cubes.py
\end_layout

\begin_layout LyX-Code
mpirun -np 16 solfec-mpi -s 16 inp/cubes.py
\end_layout

\begin_layout Standard
Because the directory 
\emph on
out/cubes
\emph default
 is specified when creating the SOLFEC obejct in the 
\emph on
inp/cubes.py
\emph default
 input file, the above commands result in creation of two output directories:
 
\emph on
out/cubes/4
\emph default
 and 
\emph on
out/cubes/16
\emph default
.
 One can then view a specific set of results by running
\end_layout

\begin_layout LyX-Code
./solfec -v -s 16 inp/cubes.py
\end_layout

\begin_layout Standard
During a parallel run Solfec updates a file named STATE, placed in the output
 directory of a simulation.
 It contains statistics relevant to the run, including an estimated time
 until the end of the simulation.
 The output directory contains as well a copy of the input file, which makes
 reading results more self-contained (it is harder to mismatch input and
 output files this way).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/viewer-1.png
	lyxscale 30
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "fig:Solfec-viewer"

\end_inset


\lang english
Solfec viewer window.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Input-language"

\end_inset

Input language
\end_layout

\begin_layout Standard
Solfec input file is essentially a Python source code.
 Python interpreter is embedded in Solfec.
 At the same time Solfec extends Python by adding a number of objects and
 routines.
 There are few general principles to remember:
\end_layout

\begin_layout Itemize
Zero based indexing is observed in routine arguments.
\end_layout

\begin_layout Itemize
Parameters after the bar | are optional.
 For example 
\emph on
FUNCTION (a, b| c, d)
\emph default
 has two optional parameters 
\emph on
c, d
\emph default
.
\end_layout

\begin_layout Itemize
Passing Solfec objects to some routines 
\emph on
empties
\emph default
 them.
 This means that a variable, that was passed as an argument, no longer stores
 data.
 For example: let 
\emph on
x = CREATE1 ()
\emph default
 create an object 
\emph on
x
\emph default
, and let 
\emph on
y = CREATE2 (x)
\emph default
 create an object 
\emph on
y
\emph default
, using 
\emph on
x
\emph default
.
 If 
\emph on
CREATE2 (x)
\emph default
 empties 
\emph on
x
\emph default
, then after the call 
\emph on
x
\emph default
 becomes an empty placeholder.
 One can use it to assign value, 
\emph on
x = CREATE1 ()
\emph default
, but using it as an argument, 
\emph on
z = CREATE2 (x)
\emph default
, will cause an abnormal termination.
 One can create a copy of an object by calling 
\emph on
z = COPY (x)
\emph default
, hence using 
\emph on
y = CREATE2 (COPY (x))
\emph default
 leaves 
\emph on
x
\emph default
 intact.
\end_layout

\begin_layout Standard
Sections below document Solfec objects and routines used for their manipulation.
\end_layout

\begin_layout Section
Solfec objects
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:CONVEX"

\end_inset

CONVEX
\end_layout

\begin_layout Standard
An object of type CONVEX is either an arbitrary convex polyhedron, or it
 is a collection of such polyhedrons.
\end_layout

\begin_layout Subsection*
obj = CONVEX (vertices, faces, volid | convex)
\end_layout

\begin_layout Standard
This routine creates a CONVEX object from a detailed input data.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONVEX object
\end_layout

\begin_layout Itemize

\series bold
vertices
\series default
 - list of vertices: [
\emph on
x0, y0, z0, x1, y1, z1, ...
\emph default
]
\end_layout

\begin_layout Itemize

\series bold
faces
\series default
 - list of faces: [
\emph on
n1, v1, v2, ..., vn1, s1, n2, v1, v2, ..., vn2, s2, ...
\emph default
], where 
\emph on
n1
\emph default
 is the number of vertices of the first face, 
\emph on
v1, v2, ..., vn1
\emph default
 enumerate the vertices in the CCW order when looking from the outside,
 and 
\emph on
s1
\emph default
 is the surface identifier of the face.
 Similarly for the second face and so on.
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
convex
\series default
 (emptied) - collection of CONVEX objects appending 
\series bold
obj
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members and methods of a CONVEX
 object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members and methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.nver
\series default
 - number of convex vertices
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.vertex (n)
\series default
 - returns a (x, y, z) tuple storing coordinates of nth vertex
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
obj = HULL (points, volid, surfid | convex)
\end_layout

\begin_layout Standard
This routine creates a CONVEX object as a convex hull of a point set.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONVEX object
\end_layout

\begin_layout Itemize

\series bold
points
\series default
 - list of points: [
\emph on
x0, y0, z0, x1, y1, z1, ...
\emph default
]
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - surface identifier common to all faces
\end_layout

\begin_layout Itemize

\series bold
convex
\series default
 (emptied) - collection of CONVEX objects appending 
\series bold
obj
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:MESH"

\end_inset

MESH
\end_layout

\begin_layout Standard
An object of type MESH describes an arbitrary volumetric mesh, comprising
 tetrahedrons, pyramids, wedges, and hexahedrons (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:elements"

\end_inset

).
 First order elements are currently supported.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/tet.eps
	lyxscale 15
	width 20col%

\end_inset


\begin_inset Graphics
	filename figures/pyr.eps
	lyxscale 15
	width 20col%

\end_inset


\begin_inset Graphics
	filename figures/wed.eps
	lyxscale 15
	width 20col%

\end_inset


\begin_inset Graphics
	filename figures/hex.eps
	lyxscale 15
	width 20col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "fig:elements"

\end_inset


\lang english
Element types in Solfec.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
obj = MESH (nodes, elements, surfids)
\end_layout

\begin_layout Standard
This routine creates a MESH object from a detailed input data.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created MESH object
\end_layout

\begin_layout Itemize

\series bold
nodes
\series default
 - list of nodes: [
\emph on
x0, y0, z0, x1, y1, z1, ...
\emph default
]
\end_layout

\begin_layout Itemize

\series bold
elements
\series default
 - list of elements: [
\emph on
e1, n1, n2, ..., ne1, v1, e2, n1, n2, ..., ne2, v2, ...
\emph default
], where 
\emph on
e1
\emph default
 is the number of nodes of the first element,
\emph on
 n1, n2, ..., ne1
\emph default
 enumerate the element nodes, and 
\emph on
v1
\emph default
 is the volume identifier of the element.
 Similarly for the second element and so on.
\end_layout

\begin_layout Itemize

\series bold
surfids
\series default
 - list of surface identifiers: [
\emph on
gid, f1, n1, n2, ..., nf1, s1, f2, n1, n2, ..., nf2, s2, ...
\emph default
], where 
\emph on
gid
\emph default
 is the global surface identifier for all not specified faces, 
\emph on
f1
\emph default
 is the number of nodes in the first specified face, 
\emph on
n1, n2, ..., nf1
\emph default
 enumerate the face nodes, and 
\emph on
s1
\emph default
 is the surface identifier of the face.
 Similarly for other specified faces.
 If only the 
\emph on
gid
\emph default
 is given, this can be done either as [
\emph on
gid
\emph default
] or as 
\emph on
gid
\emph default
 alone.
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members and methods of a MESH object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members and methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.nnod
\series default
 - number of mesh nodes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.node (n)
\series default
 - returns a (x, y, z) tuple storing coordinates of nth node
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
obj = HEX (nodes, i, j, k, volid, surfids | dx, dy, dz)
\end_layout

\begin_layout Standard
This routine creates a MESH object corresponding to a hexahedral shape (hexahedr
al elements are used).
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created MESH object
\end_layout

\begin_layout Itemize

\series bold
nodes
\series default
 - list of 8 nodes: [
\emph on
x0, y0, z0, x1, y1, z1, ...
\emph default
, x7, y7, z7].
 The hexahedral shape will be stretched between those nodes using a linear
 interpolation.
\end_layout

\begin_layout Itemize

\series bold
i, j, k
\series default
 - numbers of subdivisions along the local 
\emph on
x, y, z
\emph default
 directions.
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
surfids
\series default
 - list of six surface identifiers: [
\emph on
s1, s2, ..., s6
\emph default
], corresponding to the faces of the hexahedral shape
\end_layout

\begin_layout Itemize

\series bold
dx, dy, dz
\series default
 - lists of subdivision schemes along local 
\emph on
x, y, z
\emph default
 directions.
 By default a subdivision is uniform.
 When 
\emph on
dx = 
\emph default
[
\emph on
1, 1, 5, 5, 1, 1
\emph default
] is present, then this scheme will be normalised (actual numbers do not
 matter, but their ratios) and applied to the local x direction of the generated
 shape.
\end_layout

\begin_layout Subsection*
obj = ROUGH_HEX (shape, i, j, k | dx, dy, dz)
\end_layout

\begin_layout Standard
This routine creates a hexahedral MESH object corresponding to a given shape.
 The resultant mesh properly contains the input shape and with its orientation
 (which is based on the inertia properties of the shape).
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created MESH object
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - an input shape defined by a collection of CONVEX objects; a list of CONVEX
 objects (or their collections) 
\emph on
[cvx1, cvx2, cvx3, ....]
\emph default
 is as well accepted.
\end_layout

\begin_layout Itemize

\series bold
i, j, k
\series default
 - numbers of subdivisions along the local 
\emph on
x, y, z
\emph default
 directions of the principal inertia axes
\end_layout

\begin_layout Itemize

\series bold
dx, dy, dz
\series default
 - lists of subdivision schemes along local 
\emph on
x, y, z
\emph default
 directions.
 By default a subdivision is uniform.
 When 
\emph on
dx = 
\emph default
[
\emph on
1, 1, 5, 5, 1, 1
\emph default
] is present, then this scheme will be normalised (actual numbers do not
 matter, but their ratios) and applied to the local x direction of the generated
 shape.
\end_layout

\begin_layout Subsection*
obj = PIPE (pnt, dir, rin, thi, ndir, nrad, nthi, volid, surfids)
\end_layout

\begin_layout Standard
This routine creates a MESH object corresponding to a pipe (hexahedral elements
 are used).
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created MESH object
\end_layout

\begin_layout Itemize

\series bold
pnt
\series default
 - base point tuple 
\emph on
(x, y, z)
\end_layout

\begin_layout Itemize

\series bold
dir
\series default
 - direction tuple 
\emph on
(dx, dy, dz)
\emph default
; length of the pipe equals to the length of the direction
\end_layout

\begin_layout Itemize

\series bold
rin
\series default
 - inner radius
\end_layout

\begin_layout Itemize

\series bold
thi
\series default
 - thickness
\end_layout

\begin_layout Itemize

\series bold
ndir, nrad, nthi
\series default
 - number of subdivisions along the direction, radius and thickness
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
surfids
\series default
 - list of six surface identifiers: [
\emph on
s1, s2, ..., s6
\emph default
], corresponding to the faces of the hexahedral shape
\end_layout

\begin_layout Subsection*
obj = TETRAHEDRALIZE (shape | volume, quality, volid, surfid)
\end_layout

\begin_layout Standard
This routine creates a tetrahedral mesh.
 Tetgen is invoked internally, 
\begin_inset CommandInset href
LatexCommand href
name "http://tetgen.berlios.de/"
target "http://tetgen.berlios.de/"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created MESH object
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - an input shape can be:
\end_layout

\begin_deeper
\begin_layout Itemize
another MESH object
\end_layout

\begin_layout Itemize
a path (e.g.
 'path/to/file.stl') to an input file supported by Tetgen (e.g.
 
\begin_inset CommandInset href
LatexCommand href
name "http://tetgen.berlios.de/fformats.html"
target "http://tetgen.berlios.de/fformats.html"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
volume
\series default
 - maximum element volume (default: not enforced)
\end_layout

\begin_layout Itemize

\series bold
quality
\series default
 - value > 1.0 indicating element quality (default: not enforced); values
 close to 1.0 result in better mesh quality (mesh generation may fail for
 small values)
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier (default: 0); if only possible it is inherited from
 the input
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - surface identifier (default: 0); if only possible it is inherited from
 the input
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:SPHERE"

\end_inset

SPHERE
\end_layout

\begin_layout Standard
An object of type SPHERE is either a sphere, or it is a collections of spheres.
\end_layout

\begin_layout Subsection*
obj = SPHERE (center, radius, volid, surfid | sphere)
\end_layout

\begin_layout Standard
This routine creates a SPHERE object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created SPHERE object
\end_layout

\begin_layout Itemize

\series bold
center
\series default
 - tuple 
\emph on
(x, y, z)
\emph default
 defining the center
\end_layout

\begin_layout Itemize

\series bold
radius
\series default
 - sphere radius
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - surface identifier
\end_layout

\begin_layout Itemize

\series bold
sphere
\series default
 (emptied) - collection of SPHERE objects appending 
\series bold
obj
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a MESH object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members and methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.center, obj.radius
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:SOLFEC"

\end_inset

SOLFEC
\end_layout

\begin_layout Standard
An object of type SOLFEC represents the Solfec algorithm.
 One can use several SOLFEC objects to run several analyses from a single
 input file.
\end_layout

\begin_layout Subsection*
obj = SOLFEC (analysis, step, output)
\end_layout

\begin_layout Standard
This routine creates a SOLFEC object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
analysis
\series default
 - 'DYNAMIC' or 'QUASI_STATIC' analysis kind
\end_layout

\begin_layout Itemize

\series bold
step
\series default
 - initially assumed time step, regarded as an upper bound
\end_layout

\begin_layout Itemize

\series bold
output
\series default
 - defines the output 
\series bold
directory
\series default
 path (
\series bold
Important note:
\series default
 if this directory exists and contains valid output data SOLFEC is created
 in 'READ' mode, otherwise SOLFEC is created in 'WRITE' mode)
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a SOLFEC object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.analysis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.time
\series default
\emph default
 - current time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.mode
\series default
\emph default
 - either 'READ' or 'WRITE' as described above
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.constraints
\series default
\emph default
 - list of constraints (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:con"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.ncon
\series default
\emph default
 - number of constraints
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.bodies
\series default
\emph default
 - list of bodies (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:bod"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.nbod
\series default
\emph default
 - number of bodies
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.step
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.verbose
\series default
\emph default
 - either 'ON' or 'OFF' enabling or disabling writing to standard output
 (default: 'ON') 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:SURFACE_MATERIAL"

\end_inset

SURFACE_MATERIAL
\end_layout

\begin_layout Standard
An object of type SURFACE_MATERIAL represents material properties on the
 interface between two surfaces.
 Surfaces identifiers were included in definitions of all geometric objects.
\end_layout

\begin_layout Subsection*
obj = SURFACE_MATERIAL (solfec | surf1, surf2, model, label, friction, cohesion,
 restitution, spring, dashpot)
\end_layout

\begin_layout Standard
This routine creates a SURFACE_MATERIAL object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created SURFACE_MATERIAL object
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - 
\series bold
obj
\series default
 is created for this SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
surf1
\series default
 - first surface identifier (default: 0)
\end_layout

\begin_layout Itemize

\series bold
surf2
\series default
 - second surface identifier (default: 0).
 If 
\series bold
surf1
\series default
 or 
\series bold
surf2
\series default
 (or both) are not specified, a 
\emph on
default
\emph default
 surface material is being defined (one used when a specific surface pairing
 cannot be found for a new contact point).
\end_layout

\begin_layout Itemize

\series bold
model
\series default
 - material model name (default: 'SIGNORINI_COULOMB'), see Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:surfmats"

\end_inset

 and Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Materials"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
label
\series default
 - label string (default: 'SURFACE_MATERIAL_
\emph on
i
\emph default
', where 
\emph on
i
\emph default
 is incremented for each call)
\end_layout

\begin_layout Itemize

\series bold
friction
\series default
 - friction coefficient (default: 0.0)
\end_layout

\begin_layout Itemize

\series bold
cohesion
\series default
 - cohesion per unit area (default: 0.0)
\end_layout

\begin_layout Itemize

\series bold
restitution
\series default
 - velocity restitution (default: 0.0)
\end_layout

\begin_layout Itemize

\series bold
spring
\series default
 - spring stiffness (default: 0.0)
\end_layout

\begin_layout Itemize

\series bold
dashpot
\series default
 - dashpot stiffness (default: 0.0)
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a SURFACE_MATERIAL object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.surf1, obj.surf2, obj.label
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.model,obj.friction, obj.cohesion, obj.restitution, obj.spring, obj.dashpot
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="top" width="40col%">
<column alignment="center" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Employs variables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'SIGNORINI_COULOMB'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
friction, cohesion, restitution (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signorini-Coulomb"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'SPRING_DASHPOT'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
spring, dashpot, friction, cohesion (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Spring-dashpot"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "tab:surfmats"

\end_inset


\lang english
Surface material models.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:BULK_MATERIAL"

\end_inset

BULK_MATERIAL
\end_layout

\begin_layout Standard
An object of type BULK_MATERIAL represents material properties of a volume.
\end_layout

\begin_layout Subsection*
obj = BULK_MATERIAL (solfec| model, label, young, poisson, density)
\end_layout

\begin_layout Standard
This routine creates a BULK_MATERIAL object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created BULK_MATERIAL object
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - 
\series bold
obj
\series default
 is created for this SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
model
\series default
 - material model name (default: 'KIRCHHOFF'), see Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:bulkmats"

\end_inset

 and Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Materials"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
label
\series default
 - label string (default: 'BULK_MATERIAL_
\emph on
i
\emph default
', where 
\emph on
i
\emph default
 is incremented for each call)
\end_layout

\begin_layout Itemize

\series bold
young
\series default
 - Young's modulus (default: 1E6)
\end_layout

\begin_layout Itemize

\series bold
poisson
\series default
 - Poisson's coefficient (default: 0.25)
\end_layout

\begin_layout Itemize

\series bold
density
\series default
 - material density (default: 1E3)
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a BULK_MATERIAL object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.model, obj.label
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.young, obj.poisson, obj.density
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="center" valignment="top" width="40col%">
<column alignment="center" valignment="top" width="40col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Model name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Employs variables
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'KIRCHHOFF'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
young, poisson, density (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kirchhoff"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:bulkmats"

\end_inset

Bulk material models.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:bod"

\end_inset

BODY
\end_layout

\begin_layout Standard
An object of type BODY represents a solid body.
\end_layout

\begin_layout Subsection*
obj = BODY (solfec, kind, shape, material | label, form, mesh)
\end_layout

\begin_layout Standard
This routine creates a body.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created BODY object
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - 
\series bold
obj
\series default
 is created for this SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - a string: 'RIGID', 'PSEUDO_RIGID', 'FINITE_ELEMENT' or 'OBSTACLE' describing
 the kinematic model
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 (emptied) - this is can be a CONVEX/MESH/SPHERE object, or a list 
\emph on
[obj1, obj2, ...]
\emph default
, where each object is of type CONVEX/MESH/SPHERE.
 If the 
\series bold
kind
\series default
 is 'FINITE_ELEMENT', then two cases are possible:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
shape
\series default
 is a single MESH object: the mesh describes both the shape and the discretisati
on of the motion of a body
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 is solely composed of CONVEX objects: here a separate 
\series bold
mesh
\series default
 must be given to discretise motion of a body (see the 
\series bold
mesh
\series default
 argument below) 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
material
\series default
 - a BULK_MATERIAL object or a label of a bulk material (specifies an initial
 body-wise material, see also the 
\series bold
MATERIAL (...)
\series default
 routine in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:util"

\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
label
\series default
 - a label string (no label is assigned by default)
\end_layout

\begin_layout Itemize

\series bold
form
\series default
 - valid when 
\series bold
kind
\series default
 equals 'FINITE_ELEMENT', ignored otherwise (default: 'TL').
 This argument specifies a formulation of the finite element method.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:formulation"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
mesh
\series default
 - optional when 
\series bold
kind
\series default
 equals 'FINITE_ELEMENT', ignored otherwise.
 This variable must be a MESH object describing a finite element mesh properly
 containing the 
\series bold
shape
\series default
 composed solely of CONVEX objects.
 This way the 'FINITE_ELEMENT' model allows to handle complicated shapes
 with less finite elements, e.g.
 an arbitrary shape could be contained in just one hexahedron.
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a BODY object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.kind, obj.label
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.conf
\series default
\emph default
 - tuple 
\emph on
(q1, q2, ..., qN)
\emph default
 storing configuration of the body.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:conf"

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.velo
\series default
\emph default
 - tuple 
\emph on
(u1, u2, ..., uN)
\emph default
 storing velocity of the body.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:velo"

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.mass
\series default
\emph default
 - referential mass of the body
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.volume
\series default
\emph default
 - referential volume of the body
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.center
\series default
\emph default
 - referential mass center of the body
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.tensor
\series default
\emph default
 - referential Euler (pseudo-rigid, finite element kinematics) or inertia
 tensor (rigid kinematics) of the body
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.constraints
\series default
\emph default
 - list of constraints attached to the body (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:con"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.ncon
\series default
\emph default
 - number of constraints attached to the body
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.selfcontact
\series default
\emph default
 - self-contact detection flag (default: 'OFF
\begin_inset Quotes erd
\end_inset

) taking values 'ON' or 'OFF'.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.scheme
\series default
\emph default
 - time integration scheme (default: 'DEFAULT') used to integrate motion.
 See Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:schema"

\end_inset

.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.damping
\series default
\emph default
 - stiffness proportional damping coefficient (default: 0.0) for the dynamic
 case (ignored for rigid bodies).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features>
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Formulation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Remarks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'TL'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Total Lagrangian (default)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'BC'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Body Co-rotational (one co-rotated frame per body, suitable for stiff bodies)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "tab:formulation"

\end_inset


\lang english
Finite element formulations
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Body kind
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Configuration description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'RIGID'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Column-wise rotation matrix followed by the current mass center.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'PSEUDO_RIGID'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Column-wise deformation gradient followed by the current mass center.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'FINITE_ELEMENT'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Current coordinates x, y, z of  mesh nodes.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'OBSTACLE'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python 
\emph on
None
\emph default
 object.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:conf"

\end_inset

Types of configurations.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Body kind
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Velocity description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'RIGID'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Referential angular velocity followed by the spatial velocity of mass center.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'PSEUDO_RIGID'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deformation gradient velocity followed by the spatial velocity of mass center.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'FINITE_ELEMENT'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Components x, y, z of spatial velocities of mesh nodes.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'OBSTACLE'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Python 
\emph on
None
\emph default
 object.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:velo"

\end_inset

Types of velocities.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="center" valignment="top" width="15col%">
<column alignment="center" valignment="top" width="20col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scheme
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kinematics
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Remarks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DEFAULT'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
all
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Use a default time integrator regardless of underlying kinematics.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'RIG_POS'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rigid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEW1 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008b"

\end_inset

: explicit, positive energy drift, no momentum conservation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'RIG_NEG'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rigid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEW2 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008b"

\end_inset

: explicit, negative energy drift, exact momentum conservation; 
\series bold
default
\series default
 for rigid kinematics
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'RIG_IMP'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rigid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEW3 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008b"

\end_inset

: semi-explicit, no energy drift and exact momentum conservation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DEF_EXP'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pseudo-rigid, finite element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Explicit scheme described in Chapter 5 of 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008PhD"

\end_inset

; 
\series bold
default
\series default
 for deformable kinematics, energy and momentum conserving, conditionally
 stable
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DEF_LIM'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pseudo-rigid, finite element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linearly implicit scheme similar to 
\begin_inset CommandInset citation
LatexCommand cite
key "Zhang1997"

\end_inset

; energy and momentum conserving, stable for moderate steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DEF_LIM2'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pseudo-rigid, finite element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linearly implicit scheme similar to 
\begin_inset CommandInset citation
LatexCommand cite
key "Potra2006"

\end_inset

; strong numerical dissipation, stable for large steps
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DEF_IMP'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pseudo-rigid, finite element
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implicit scheme similar to 
\begin_inset CommandInset citation
LatexCommand cite
key "Chawla1998"

\end_inset

; energy and momentum conserving, stable for large steps
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:schema"

\end_inset

Time integration schema.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TIME_SERIES
\end_layout

\begin_layout Standard
An object of type TIME_SERIES is a linear spline based on a series of 2-points.
\end_layout

\begin_layout Subsection*
obj = TIME_SERIES (points)
\end_layout

\begin_layout Standard
This routine creates a TIME_SERIES object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created TIME_SERIES object
\end_layout

\begin_layout Itemize

\series bold
points
\series default
 - either a list 
\emph on
[t0, v0, t1, v1, ....]
\emph default
 of points (where 
\emph on
ti < tj
\emph default
, when 
\emph on
i < j
\emph default
), or a path to a file storing times and values pairs in format:
\end_layout

\begin_layout LyX-Code
t0 v0
\end_layout

\begin_layout LyX-Code
t1 v1
\end_layout

\begin_layout LyX-Code
...
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:GAUSS_SEIDEL_SOLVER"

\end_inset

GAUSS_SEIDEL_SOLVER
\end_layout

\begin_layout Standard
An object of type GAUSS_SEIDEL_SOLVER represents a nonlinear block Gauss-Seidel
 solver, employed for the calculation of constraint reactions (cd.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Gauss-Seidel-solver"

\end_inset

).
\end_layout

\begin_layout Subsection*
obj = GAUSS_SEIDEL_SOLVER (epsilon, maxiter | meritval, failure, diagepsilon,
 diagmaxiter, diagsolver, data, callback)
\end_layout

\begin_layout Standard
This routine creates a GAUSS_SEIDEL_SOLVER object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created GAUSS_SEIDEL_SOLVER object
\end_layout

\begin_layout Itemize

\series bold
epsilon
\series default
 - relative accuracy of constraint reactions sufficient for termination
\end_layout

\begin_layout Itemize

\series bold
maxiter
\series default
 - maximal number of iterations before termination
\end_layout

\begin_layout Itemize

\series bold
meritval
\series default
 - constraints satisfaction merit function value sufficient for termination
 (default: 1E-3), cf.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Constraints-accuracy"

\end_inset

 for more details.
\end_layout

\begin_layout Itemize

\series bold
failure
\series default
 - failure (lack of convergence) action (default: 'CONTINUE').
 Available failure actions are: 'CONTINUE' (simulation is continued), 'EXIT'
 (simulation is stopped and Solfec exits), 'CALLBACK' (a callback function
 is called if it was set or otherwise the 'EXIT' scenario is executed).
 In all cases 
\series bold
\emph on
obj.error
\series default
\emph default
 variable is set up, cf.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:err-gs"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
diagepsilon
\series default
 - diagonal block solver relative accuracy of constraint reactions (default:
 
\emph on
min (epsilon, meritval, 1E-4) / 100
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
diagmaxiter
\series default
 - diagonal block solver maximal number of iterations (default: 
\emph on
max (100, maxiter / 100)
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
diagsolver
\series default
 - diagonal block solver kind (default: 'SEMISMOOTH_NEWTON').
 Available diagonal solvers are 'SEMISMOOTH_NEWTON', 'PROJECTED_GRADIENT',
 'DE_SAXCE_FENG', 'PROJECTED_NEWTON', cf.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Solvers"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
data
\series default
 - data passed to the failure callback function (if this is a tuple it will
 accordingly expand the parameter list of the callback routine)
\end_layout

\begin_layout Itemize

\series bold
callback
\series default
 - failure callback function of form: 
\emph on
value = callback (obj, data)
\emph default
, where for the returned value equal zero Solfec run is stopped
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a GAUSS_SEIDEL_SOLVER
 object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="1">
<features>
<column alignment="left" valignment="top" width="95col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.failure
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.error
\series default
 
\emph default
- current error code, cf.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:err-gs"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.iters
\series default
\emph default
 - number of iterations during a last run of solver
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.rerhist
\series default
\emph default
 - a list of relative error values for each iteration of the last run
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.merhist
\series default
\emph default
 - a list of merit function values for each iteration of the last run
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features>
<column alignment="left" valignment="top" width="95col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.epsilon, obj.maxiter, obj.meritval, obj.diagepsilon, obj.diagmaxiter, obj.diagsolv
er
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.reverse
\series default
\emph default
 - 'ON' or 'OFF' flag switching iteration reversion modes (whether to alternate
 backward and forward or not, default is 'OFF')
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.variant
\series default
\emph default
 - variant of parallel Gauss-Seidel update (default: 'FULL'), cf.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:var-gs"

\end_inset

.
 Ignored in sequential mode.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.innerloops
\series default
\emph default
 - number of inner Gauss-Seidel loops per one global step during a parallel
 run (default: 1).
 Ignored in sequential mode.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'OK'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No error has occurred
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DIVERGED'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global iteration loop divergence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DIAGONAL_DIVERGED'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Diagonal solver iteration loop divergence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'DIAGONAL_FAILED'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Failure of a diagonal solver (e.g.
 singularity)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:err-gs"

\end_inset

Error codes of GAUSS_SEIDEL_SOLVER object.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="center" valignment="top" width="30col%">
<column alignment="center" valignment="top" width="60col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'FULL'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Full Gauss-Seidel update as in sequential case.
 Although the slowest, it works in all cases.
 It should be noted, that all of the below variants will usually fail for
 all-rigid-body models.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'MIDDLE_JACOBI'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Jacobi update for off-processor data of 
\begin_inset Formula $\mathbf{W}$
\end_inset

 matrix blocks communicating with processors of higher and lower colors.
 Of use for deformable kinematics, where off-diagonal interactions are weaker.
 The Gauss-Seidel run-time should be halved for large numbers of processors.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'BOUNDARY_JACOBI'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Use Jacobi update for all off-processor data.
 This approach will fail in most cases.
 It servers as illustration.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'SIMPLIFIED'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A single sweep over contacts is done with previous values of off-processor
 data.
 This is followed by local Gauss-Seidel iterations for all non-contact constrain
ts.
 This is the fastest and least consistent approach, of use for deformable
 kinematics dominated models.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:var-gs"

\end_inset

Variants of parallel Gauss-Seidel update.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PENALTY_SOLVER
\end_layout

\begin_layout Standard
An object of type PENALTY_SOLVER represents a penalty based constraint solver
 (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Penalty-solver"

\end_inset

).
 When in use, all 'SIGNORONI_COULOMB' type contact interfaces are regarded
 as 'SPRING_DASHPOT' ones.
 One should then remember about specifying the 
\emph on
spring
\emph default
 value for those.
\end_layout

\begin_layout Subsection*
obj = PENALTY_SOLVER ( | variant)
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created PENALTY_SOLVER object
\end_layout

\begin_layout Itemize

\series bold
variant
\series default
 - 'IMPLICIT' or 'EXPLICIT' normal force computation variant (default: 'IMPLICIT
')
\end_layout

\begin_layout Subsection
NEWTON_SOLVER 
\color red
(Under development)
\end_layout

\begin_layout Standard
Object of type NEWTON_SOLVER represents a projected quasi-Newton constraints
 solver.
\end_layout

\begin_layout Subsection*
obj = NEWTON_SOLVER (| meritval, maxiter, locdyn, theta, epsilon, presmooth)
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created NEWTON_SOLVER object
\end_layout

\begin_layout Itemize

\series bold
meritval
\series default
 - value of merit function sufficient for termination (default: 1E-8), cf.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Constraints-accuracy"

\end_inset

 for more details
\end_layout

\begin_layout Itemize

\series bold
maxiter
\series default
 - iterations bound (default: 100)
\end_layout

\begin_layout Itemize

\series bold
locdyn
\series default
 - 'ON' or 'OFF' deciding whether to fully assemble local dynamics (default:
 'ON')
\end_layout

\begin_layout Itemize

\series bold
theta
\series default
 - relaxation parameter greater than 0 and not greater than 1 (default:
 0.25); theta is automatically decreased in case of numerical instability;
 smaller initial theta may improve overall convergence behavior
\end_layout

\begin_layout Itemize

\series bold
epsilon
\series default
 - non-negative smoothing epsilon (default: 1E-9)
\end_layout

\begin_layout Itemize

\series bold
presmooth
\series default
 - number of Gauss-Seidel pre-smoothing steps (default: 0); pre-smoothing
 is only performed when 
\series bold
locdyn
\series default
 value is 'ON'
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a NEWTON_SOLVER object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features>
<column alignment="left" valignment="top" width="95col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.iters
\series default
\emph default
 - number of iterations during a last run of solver
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.merhist
\series default
\emph default
 - a list of merit function values for each iteration of the last run
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="left" valignment="top" width="95col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read/write
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
obj.meritval, obj.maxiter, obj.locdyn, obj.theta, obj.epsilon, obj.presmooth
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:con"

\end_inset

CONSTRAINT
\end_layout

\begin_layout Standard
An object of type CONSTRAINT represents a constraint and some of its associated
 data (e.g.
 constraint reaction).
 Both user prescribed constraints and contact constraints are represented
 by an object of the same type.
\end_layout

\begin_layout Subsection*
obj = FIX_POINT (body, point)
\end_layout

\begin_layout Standard
This routine creates a fixed point constraint.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple with referential point coordinates
\end_layout

\begin_layout Subsection*
obj = FIX_DIRECTION (body, point, direction)
\end_layout

\begin_layout Standard
This routine fixes the motion of a referential point along a specified spatial
 direction.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 -
\emph on
 (x, y, z)
\emph default
 tuple with referential point coordinates
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple with spatial direction components
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection*
obj = FIX_SURFACE (body, surfid, direction)
\color red
 TODO
\end_layout

\begin_layout Plain Layout
This routine fixes the motion of a referential surface along a specified
 spatial direction.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - list of created point CONSTRAINT objects
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 -
\emph on
 
\emph default
surface identifier
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple defining the direction of load, or 'NORMAL' if load is normal to
 the surface, or 'TANGENT1' if load acts along the first tangent direction,
 or 'TANGENT2' if it acts along the second tangent direction.
 The normal direction ('NORMAL') is outward.
 The first tangent direction ('TANGENT1') is the one of the steepest descent,
 or a global 
\emph on
x
\emph default
 direction if the surface is horizontal.
 The second tangent direction ('TANGENT2') is such that the local ('TANGENT1',
 'TANGENT2', 'NORMAL') coordinate system is right-handed.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
obj = SET_DISPLACEMENT (body, point, direction, tms)
\end_layout

\begin_layout Standard
This routine prescribes a displacement history of a referential point along
 a specified spacial direction.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple with referential point coordinates
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple with spatial direction components
\end_layout

\begin_layout Itemize

\series bold
tms
\series default
 - TIME_SERIES object with the displacement history
\end_layout

\begin_layout Subsection*
obj = SET_VELOCITY (body, point, direction, value)
\end_layout

\begin_layout Standard
This routine prescribes a velocity history of a referential point along
 a specified spacial direction.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple with referential point coordinates
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple with spatial direction components
\end_layout

\begin_layout Itemize

\series bold
value
\series default
 - a constant value or a TIME_SERIES object with the velocity history
\end_layout

\begin_layout Subsection*
obj = SET_ACCELERATION (body, point, direction, tms)
\end_layout

\begin_layout Standard
This routine prescribes an acceleration history of a referential point along
 a specified spacial direction.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object whose motion is constrained
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple with referential point coordinates
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple with spatial direction components
\end_layout

\begin_layout Itemize

\series bold
tms
\series default
 - TIME_SERIES object with the acceleration history
\end_layout

\begin_layout Subsection*
obj = PUT_RIGID_LINK (body1, body2, point1, point2)
\end_layout

\begin_layout Standard
This routine creates a rigid link constraints between two referential points
 of two distinct bodies.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created CONSTRAINT object
\end_layout

\begin_layout Itemize

\series bold
body1
\series default
 - BODY object one whose motion is constrained (could be 
\emph on
None
\emph default
 when 
\series bold
body2
\series default
 is not 
\emph on
None
\emph default
 - then one of the points is fixed 
\begin_inset Quotes eld
\end_inset

in the air
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
body2
\series default
 - BODY object two whose motion is constrained (could be 
\emph on
None
\emph default
 when 
\series bold
body1
\series default
 is not 
\emph on
None
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
point1
\series default
 - 
\emph on
(x1, y1, z1)
\emph default
 tuple with the first referential point coordinates
\end_layout

\begin_layout Itemize

\series bold
point2
\series default
 - 
\emph on
(x2, y2, z2)
\emph default
 tuple with the second referential point coordinates
\end_layout

\begin_layout Standard
Some parameters can also be accessed as members of a CONSTRAINT object.
 These are
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="1">
<features>
<column alignment="left" valignment="top" width="80col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Read-only
\series default
 members
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.kind
\series default
 
\emph default
- kind of constraint: 'CONTACT', 'FIXPNT' (fixed point), 'FIXDIR' (fixed
 direction), 'VELODIR' (prescribed velocity; note that prescribed displacement
 and acceleration are converted into this case), 'RIGLNK' (rigid link)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.R
\series default
\emph default
 - current average (over time step 
\begin_inset Formula $\left[t,t+h\right]$
\end_inset

) constraint reaction in a form of a tuple: 
\emph on
(RT1, RT2, RN)
\emph default
 given with respect to a local base stored at 
\series bold
\emph on
obj.base
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.base
\series default
\emph default
 - current spatial coordinate system in a form of a tuple: 
\emph on
(eT1x, eT2x, eNx, eT1y, eT2y, eNy, eT1z, eT2z, eNz)
\emph default
 where 
\emph on
x, y, z
\emph default
 components are global
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.point
\series default
\emph default
 - current spatial point where the constraint force acts.
 This is a 
\emph on
(x, y, z)
\emph default
 tuple for all constraint types, but 'RIGLNK' for which this is a 
\emph on
(x1, y1, z1, x2, y2, z2)
\emph default
 tuple.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.area
\series default
\emph default
 - current area for contact constraints or zero otherwise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.gap
\series default
\emph default
 - current gap for contact constraints or zero otherwise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.merit
\series default
\emph default
 - current value of the per-constraint merit function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.adjbod
\series default
\emph default
 - adjacent bodies.
 This is a tuple (body1, body2) of BODY objects for 'CONTACT' and 'RIGLNK'
 or a single BODY object otherwise.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\emph on
obj.matlab
\series default
\emph default
 - surface material label for constraints of kind 'CONTACT', or a 
\emph on
None
\emph default
 object otherwise.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Applying loads
\end_layout

\begin_layout Standard
Routines listed in this section apply loads.
\end_layout

\begin_layout Subsection*
GRAVITY (solfec, vector)
\end_layout

\begin_layout Standard
This routine sets up the gravitational acceleration.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object for which the acceleration is set up
\end_layout

\begin_layout Itemize

\series bold
vector
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple defining the gravity acceleration.
 Each entry is a number or a TIME_SERIES object defining the value of the
 acceleration component.
\end_layout

\begin_layout Subsection*
FORCE (body, kind, point, direction, value| data)
\end_layout

\begin_layout Standard
This routine applies a point force to a body.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object to which the force is applied
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - either 'SPATIAL' or 'CONVECTED'; the 
\emph on
spatial
\emph default
 direction remains fixed, while the 
\emph on
convected
\emph default
 one follows deformation
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple with the referential point where the force is applied
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 -
\emph on
 (vx, vy, vz)
\emph default
 tuple defining the direction of force
\end_layout

\begin_layout Itemize

\series bold
value
\series default
 - a number, a TIME_SERIES object or a callback routine defining the value
 of the applied force.
 In case of a callback routine, the following format is assumed: 
\end_layout

\begin_layout Standard
\align right
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
width "95col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\series bold
\emph on
force = value_callback (data, q, u, time, step)
\end_layout

\begin_layout Plain Layout
where: 
\series bold
data
\series default
 is the optional user data passed to 
\series bold
FORCE
\series default
 routine (if 
\series bold
data
\series default
 is a tuple it will expand the list of parameters to the callback), 
\series bold
q
\series default
 is the configuration of the body passed to the callback, 
\series bold
u
\series default
 is the velocity of the body passed to the callback, 
\series bold
time
\series default
 is the current time passed to the callback and 
\series bold
step
\series default
 is the current time step passed to the callback.
 The callback returnes a 
\series bold
force
\series default
 tuple.
 For rigid body the force reads 
\emph on
(spatial force, spatial torque, referential torque)
\emph default
, while for other hinds of bodies this is a generalised force of the same
 dimension as the velocity 
\series bold
u
\series default
 (power conjugate to it).
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
data
\series default
 - callback routine user data
\end_layout

\begin_layout Subsection*
TORQUE (body, kind, direction, value)
\end_layout

\begin_layout Standard
This routine applies a torque to a 
\emph on
rigid
\emph default
 body.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object of kind 'RIGID' to which the torque is applied
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - either 'SPATIAL' or 'CONVECTED'; the 
\emph on
spatial
\emph default
 direction remains fixed, while the 
\emph on
convected
\emph default
 one follows deformation
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 -
\emph on
 (vx, vy, vz)
\emph default
 tuple defining the direction of torque
\end_layout

\begin_layout Itemize

\series bold
value
\series default
 - a number or a TIME_SERIES object defining the value of the applied torque
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection*
LOAD (body, kind, surfid, direction, value)
\color red
 TODO
\end_layout

\begin_layout Plain Layout
This routine applies a surface load.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object to which the load is applied
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - either 'SPATIAL' or 'CONVECTED'; the 
\emph on
spatial
\emph default
 direction remains fixed, while the 
\emph on
convected
\emph default
 one follows deformation
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - the integer surface identifier
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple defining the direction of load, or 'NORMAL' if load is normal to
 the surface, or 'TANGENT1' if load acts along the first tangent direction,
 or 'TANGENT2' if it acts along the second tangent direction.
 The normal direction ('NORMAL') is outward.
 The first tangent direction ('TANGENT1') is the one of the steepest descent,
 or a global 
\emph on
x
\emph default
 direction if the surface is horizontal.
 The second tangent direction ('TANGENT2') is such that the local ('TANGENT1',
 'TANGENT2', 'NORMAL') coordinate system is right-handed.
\end_layout

\begin_layout Itemize

\series bold
value
\series default
 - a number or a TIME_SERIES object defining the value of the applied load
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cracking 
\color red
(Under development)
\end_layout

\begin_layout Standard
Routines listed in this section control cracking of bodies.
\end_layout

\begin_layout Subsection*
SIMPLIFIED_CRACK (body, point, normal, surfid, criterion | ft, Gf) 
\color red
(Under development)
\end_layout

\begin_layout Standard
This routine prescribes a potential body-wise planar cracks together with
 a cracking criterion.
 Creation of a simplified crack results in splitting of the body in two
 parts.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - a pseudo-rigid or FEM based BODY object
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - crack plane referential point 
\begin_inset Formula $\left(x,y,z\right)$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
normal
\series default
 - crack plane referential normal 
\begin_inset Formula $\left(n_{x},n_{y},n_{z}\right)$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - crack surface identifier
\end_layout

\begin_layout Itemize

\series bold
criterion
\series default
 - cracking criterion, cf.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Cracking-criteria"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
ft
\series default
 - tensile strength (default: 0.0)
\end_layout

\begin_layout Itemize

\series bold
Gf
\series default
 - fracture energy (default: 0.0)
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="20col%">
<column alignment="center" valignment="top" width="50col%">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Criterion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Parameters
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
'TENSILE'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ft, Gf
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tensile stress at any point of the the crack plane is larger than the tensile
 strength.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Cracking-criteria"

\end_inset

Cracking criteria.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:sol"

\end_inset

Running simulations
\end_layout

\begin_layout Standard
Routines listed in this section control the solution process.
\end_layout

\begin_layout Subsection*
RUN (solfec, solver, duration)
\end_layout

\begin_layout Standard
This routine runs a simulation.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
solver
\series default
 - constraint solver object (e.g.
 GAUSS_SEIDEL_SOLVER, PENALTY_SOLVER)
\end_layout

\begin_layout Itemize

\series bold
duration
\series default
 - duration of analysis
\end_layout

\begin_layout Subsection*
OUTPUT (solfec, interval | compression)
\end_layout

\begin_layout Standard
This routine specifies the frequency of writing to the output file.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
interval
\series default
 - length of the time interval elapsing before consecutive output file writes
\end_layout

\begin_layout Itemize

\series bold
compression
\series default
 - output compression mode: 'OFF' (default) or 'ON'.
 Compressed output files are smaller, although they might not be portable
 between hardware platforms.
\end_layout

\begin_layout Subsection*
EXTENTS (solfec, extents)
\end_layout

\begin_layout Standard
This routine bounds the simulation space.
 Bodies falling outside of the extents are deleted from the simulation.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
extents
\series default
 - 
\emph on
(xmin, ymin, zmin, xmax, ymax, zmax)
\emph default
 tuple
\end_layout

\begin_layout Subsection*
CALLBACK (solfec, interval, data, callback)
\end_layout

\begin_layout Standard
This routine defines a callback function, invoked during a run of Solfec
 every interval of time.
 A callback routine can interrupt the course of 
\series bold
RUN
\series default
 command by returning 0.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
interval
\series default
 - length of the time interval elapsing before consecutive callback calls
\end_layout

\begin_layout Itemize

\series bold
data
\series default
 - data passed to the callback function
\end_layout

\begin_layout Itemize

\series bold
callback
\series default
 - callback function of form: 
\emph on
value = callback (data)
\emph default
, where for the returned value equal zero Solfec run is stopped
\end_layout

\begin_layout Subsection*
UNPHYSICAL_PENETRATION (solfec, depth)
\end_layout

\begin_layout Standard
This routine sets a depth of an unphysical interpenetration.
 Once it is exceeded, the simulation is stopped and a suitable error message
 printed out.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
depth
\series default
 - interpenetration depth bound (default: 
\begin_inset Formula $\infty$
\end_inset

)
\end_layout

\begin_layout Subsection*
GEOMETRIC_EPSILON (epsilon)
\end_layout

\begin_layout Standard
This routine sets a numerical tolerance for geometric tests performed within
 Solfec.
 The tolerance is a characteristic distance between two distinct points
 below which they can be regarded as one.
\end_layout

\begin_layout Itemize

\series bold
epsilon
\series default
 - geometrical tolerance (default: 1E-6)
\end_layout

\begin_layout Subsection*
WARNINGS (state)
\end_layout

\begin_layout Standard
This routine disables or enables Solfec warnings.
 It is a good practice to have the warnings enabled and only switch them
 off after making sure, that they can be ignored.
\end_layout

\begin_layout Itemize

\series bold
state
\series default
 - 'ON' or 'OFF' (default: 'ON')
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:util"

\end_inset

Utilities
\end_layout

\begin_layout Standard
Various utility routines are listed below.
\end_layout

\begin_layout Subsection*
IMBALANCE_TOLERANCE (solfec, tolerance | lockdir, degenratio, weightfactor)
\end_layout

\begin_layout Standard
This routine sets the imbalance tolerance for parallel balancing of Solfec
 data.
 A ratio of maximal to minimal per processor count of objects used.
 Hence, 1.0 indicates perfect balance, while any ratio > 1.0 indicates an
 imbalance.
 Initially imbalance tolerances are all set to 1.3.
 This routine is ignored during sequential runs.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
tolerance
\series default
 - data imbalance tolerance (default: 1.3)
\end_layout

\begin_layout Itemize

\series bold
lockdir
\series default
 - 'ON' or 'OFF' flag indicating whether to lock initial space subdivision
 directions (default: 'OFF').
 Locked directions can decrease the communication needs at the cost of a
 lower quality of the domain partitioning.
\end_layout

\begin_layout Itemize

\series bold
degenratio
\series default
 - a number bigger than 1.0 (default: 10.0).
 If the domain bounding box has an edge ratio smaller than 1.0 / degenratio,
 a lower-dimensional load balancing algorithm is invoked.
\end_layout

\begin_layout Itemize

\series bold
weightfactor
\series default
 - a local dynamics weight factor between 0.0 and 1.0 (default: 1.0).
 Computational load of local dynamics assembling is best balanced when weightfac
tor equals 1.0.
 This however can sometimes result in a poor load balance for contact detection
 or time integration.
 Making it smaller than 1.0 can improve the overall balance in such cases.
\end_layout

\begin_layout Subsection*
num = RANK ()
\end_layout

\begin_layout Standard
This routine returns the rank of the CPU that runs the current copy of Solfec.
\end_layout

\begin_layout Itemize

\series bold
num
\series default
 - the CPU rank
\end_layout

\begin_layout Subsection*
num = NCPU (solfec)
\end_layout

\begin_layout Standard
This routine returns the number CPUs used in the analysis.
\end_layout

\begin_layout Itemize

\series bold
num
\series default
 - the number of CPUs
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Subsection*
ret = HERE (solfec, object)
\end_layout

\begin_layout Standard
This routine tests whether an object is located on the current processor.
 During parallel runs objects migrate between processors.
 When calling a function (or a member) for an object not present on the
 current processor, the call will usually return None or be ignored.
 Hence, it is convenient to check whether an object resides on the current
 processor.
\end_layout

\begin_layout Itemize

\series bold
ret
\series default
 - 
\emph on
True
\emph default
 or 
\emph on
False
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
object
\series default
 - BODY or CONSTRAINT object
\end_layout

\begin_layout Subsection*
obj = VIEWER ()
\end_layout

\begin_layout Standard
This routine tests whether the viewer is enabled.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - 
\emph on
True
\emph default
 or 
\emph on
False
\emph default
 depending on whether the viewer (
\emph on
-v
\emph default
 command line option) was enabled
\end_layout

\begin_layout Subsection*
BODY_CHARS (body, mass, volume, center, tensor)
\end_layout

\begin_layout Standard
This routine overwrites referential characteristics of a body.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
mass
\series default
 - body mass
\end_layout

\begin_layout Itemize

\series bold
volume
\series default
 - body volume
\end_layout

\begin_layout Itemize

\series bold
center
\series default
 - 
\emph on
(x, y, z)
\emph default
 mass center
\end_layout

\begin_layout Itemize

\series bold
tensor
\series default
 - 
\begin_inset Formula $\left(t_{11},t_{21},\,...\,,t_{33}\right)$
\end_inset

 column-wise inertia tensor for a rigid body or Euler tensor otherwise
\end_layout

\begin_layout Subsection*
INITIAL_VELOCITY (body, linear, angular)
\end_layout

\begin_layout Standard
This routine applies initial (at time zero) linear and angular (in the sense
 of rigid motion) velocity to a body.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
linear
\series default
 - linear velocity 
\emph on
(
\begin_inset Formula $v_{x},v_{y},v_{z}$
\end_inset

)
\end_layout

\begin_layout Itemize

\series bold
angular
\series default
 - angular velocity (
\begin_inset Formula $\omega_{x},\omega_{y},\omega_{z}$
\end_inset

 )
\end_layout

\begin_layout Subsection*
MATERIAL (solfec, body, volid, material)
\end_layout

\begin_layout Standard
This routine applies material to a subset of geometric objects with the
 given volume identifier.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
volid
\series default
 - volume identifier
\end_layout

\begin_layout Itemize

\series bold
material
\series default
 - MATERIAL object or material label
\end_layout

\begin_layout Subsection*
DELETE (solfec, object)
\end_layout

\begin_layout Standard
This routine deletes a BODY object or a CONSTRAINT object from a SOLFEC
 object.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
object
\series default
 (emptied) - BODY or CONSTRAINT object
\end_layout

\begin_layout Subsection*
obj = SCALE (shape, coefs)
\end_layout

\begin_layout Standard
This routine scales a geometrical object or a collection of such objects.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - when 
\series bold
shape
\series default
 is not 
\emph on
(x, y, z)
\emph default
 tuple: same as 
\series bold
shape
\series default
, returned for convenience.
 Otherwise the 
\emph on
(
\emph default

\begin_inset Formula $x\cdot coefs[0]$
\end_inset

, 
\begin_inset Formula $y\cdot coefs[1]$
\end_inset

, 
\begin_inset Formula $z\cdot coefs[2]$
\end_inset


\emph on
)
\emph default
 tuple.
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
 Alternately this can be a single 
\emph on
(x, y, z)
\emph default
 tuple, but then one must use 
\series bold
point = SCALE (point, coefs)
\series default
 in order to modify the 
\series bold
point
\series default
 (Python tuples are immutable - they cannot be modified 
\begin_inset Quotes eld
\end_inset

in place
\begin_inset Quotes erd
\end_inset

 after creation).
\end_layout

\begin_layout Itemize

\series bold
coefs
\series default
 - 
\emph on
(cx, cy, cz)
\emph default
 tuple of scaling factors along each axis
\end_layout

\begin_layout Subsection*
obj = TRANSLATE (shape, vector)
\end_layout

\begin_layout Standard
This routine translates a geometrical object or a collection of such objects.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - when 
\series bold
shape
\series default
 is not 
\emph on
(x, y, z)
\emph default
 tuple: same as 
\series bold
shape
\series default
, returned for convenience.
 Otherwise the 
\emph on
(
\emph default

\begin_inset Formula $x+vector[0]$
\end_inset

, 
\begin_inset Formula $y+vector[1]$
\end_inset

, 
\begin_inset Formula $z+vector[2]$
\end_inset


\emph on
)
\emph default
 tuple.
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
 Alternately this can be a single 
\emph on
(x, y, z)
\emph default
 tuple, but then one must use 
\series bold
point = TRANSLATE (point, vector)
\series default
 in order to modify the 
\series bold
point
\series default
 (Python tuples are immutable - they cannot be modified 
\begin_inset Quotes eld
\end_inset

in place
\begin_inset Quotes erd
\end_inset

 after creation).
\end_layout

\begin_layout Itemize

\series bold
vector
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple defining the translation
\end_layout

\begin_layout Subsection*
obj = ROTATE (shape, point, vector, angle)
\end_layout

\begin_layout Standard
This routine rotates a geometrical object or a collection of such objects.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - when 
\series bold
shape
\series default
 is not 
\emph on
(x, y, z)
\emph default
 tuple: same as 
\series bold
shape
\series default
, returned for convenience.
 Otherwise the rotated 
\emph on
(x1, y1, z1)
\emph default
 image of 
\emph on
(x, y, z)
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
 Alternately this can be a single 
\emph on
(x, y, z)
\emph default
 tuple, but then one must use 
\series bold
point1 = ROTATE (point1, point2, vector, angle)
\series default
 in order to modify 
\series bold
point1
\series default
 (Python tuples are immutable - they cannot be modified 
\begin_inset Quotes eld
\end_inset

in place
\begin_inset Quotes erd
\end_inset

 after creation).
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(px, py, pz)
\emph default
 tuple defining a point passed by the rotation axis
\end_layout

\begin_layout Itemize

\series bold
vector
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple defining a direction of the rotation axis
\end_layout

\begin_layout Itemize

\series bold
angle
\series default
 - rotation angle in degrees
\end_layout

\begin_layout Subsection*
(one, two) = SPLIT (shape, point, normal | surfid)
\end_layout

\begin_layout Standard
This routine splits a geometrical object (or a collection of objects) by
 a plane passing by a point.
\end_layout

\begin_layout Itemize

\series bold
one
\series default
 - objects placed below the splitting plane (
\emph on
None
\emph default
 if no objects were placed below)
\end_layout

\begin_layout Itemize

\series bold
two
\series default
 - objects placed above the splitting plane (
\emph on
None
\emph default
 if no objects were placed above)
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 (emptied) - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, SPHERE or MESH
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(px, py, pz)
\emph default
 tuple defining a point passed by the splitting plane
\end_layout

\begin_layout Itemize

\series bold
normal
\series default
 - 
\emph on
(nx, ny, nz)
\emph default
 tuple defining the splitting plane normal
\end_layout

\begin_layout Itemize

\series bold
surfid
\series default
 - surface identidier of a newly created surface (default: 0)
\end_layout

\begin_layout Subsection*
obj = COPY (shape)
\end_layout

\begin_layout Standard
This routine makes a copy of input objects.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - created collection of copied objects
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE
\end_layout

\begin_layout Subsection*
obj = BEND (shape, point, direction, angle)
\end_layout

\begin_layout Standard
This routine bends a shape around an axis.
 The bending is performed from the section of the shape closest to the axis
 onward.
 The orientation of the axis direction determines the orientation of the
 bending according to the right hand rule.
 Let 
\begin_inset Formula $\mathbf{q}$
\end_inset

 be the closest to the axis mesh node.
 Then 
\begin_inset Formula $\mathbf{v}=\mathbf{d}\times\left(\mathbf{q}-\mbox{proj}\left(\mathbf{q}\right)\right)$
\end_inset

, where 
\begin_inset Formula $\mathbf{d}$
\end_inset

 is the axis direction and 
\begin_inset Formula $\mbox{proj\left[\cdot\right]}$
\end_inset

 projects a point onto the axis.
 Bending starts from the section containing 
\begin_inset Formula $\mathbf{q}$
\end_inset

 and proceeds in the direction of 
\begin_inset Formula $\mathbf{v}$
\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - same as 
\series bold
shape
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object of type MESH
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - axis point
\end_layout

\begin_layout Itemize

\series bold
direction
\series default
 - axis direction
\end_layout

\begin_layout Itemize

\series bold
angle
\series default
 - positive bending angle in degrees
\end_layout

\begin_layout Subsection*
obj = BYLABEL (solfec, kind, label)
\end_layout

\begin_layout Standard
This routine finds a labelled object inside of a SOLFEC object.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - returned object (
\emph on
None
\emph default
 if a labelled object was not found)
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - labelled object: 'SURFACE_MATERIAL', 'BULK_MATERIAL', 'BODY'
\end_layout

\begin_layout Itemize

\series bold
label
\series default
 - the label string
\end_layout

\begin_layout Subsection*
obj = MASS_CENTER (shape)
\end_layout

\begin_layout Standard
This routine calculates the mass center of a geometrical object or a collection
 of such objects.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple storing the mass center
\end_layout

\begin_layout Itemize

\series bold
shape
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
 Alternately this can be a single
\emph on
 
\emph default
BODY object.
\end_layout

\begin_layout Subsection*
CONTACT_EXCLUDE_BODIES (body1, body2)
\end_layout

\begin_layout Standard
This routine disables contact detection for a specific pair of bodies.
 By default contact detection is enabled for all possible body pairs.
 
\series bold
NOTE:
\series default
 
\emph on
must be invoked on all processors during a parallel run (do not use from
 within a callback).
\end_layout

\begin_layout Itemize

\series bold
body1
\series default
 - first BODY object
\end_layout

\begin_layout Itemize

\series bold
body2
\series default
 - second BODY object
\end_layout

\begin_layout Subsection*
CONTACT_EXCLUDE_SURFACES (solfec, surf1, surf2)
\end_layout

\begin_layout Standard
This routine disables contact detection for a specific pair of surfaces.
 By default contact detection is enabled for all possible surface pairs.
 
\series bold
NOTE:
\series default
 
\emph on
must be invoked on all processors during a parallel run (do not use from
 within a callback).
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
surf1
\series default
 - first BODY object
\end_layout

\begin_layout Itemize

\series bold
surf2
\series default
 - second BODY object
\end_layout

\begin_layout Subsection*
CONTACT_EXCLUDE_OBJECTS (body1, point1, body2, point2)
\end_layout

\begin_layout Standard
This routine disables contact detection for a specific pair of geometric
 objects (e.g.
 elements, convices, sheres).
 By default, between different bodies, contact detection is enabled for
 all possible object pairs.
 
\series bold
NOTE:
\series default
 
\emph on
must be invoked on all processors during a parallel run (do not use from
 within a callback).
\end_layout

\begin_layout Itemize

\series bold
body1
\series default
 - first BODY object
\end_layout

\begin_layout Itemize

\series bold
point1
\series default
 - referential point properly contained in the 1st geometric object
\end_layout

\begin_layout Itemize

\series bold
bod2
\series default
 - second BODY object
\end_layout

\begin_layout Itemize

\series bold
point2
\series default
 - referential point properly contained in the 2nd geometric object
\end_layout

\begin_layout Subsection*
CONTACT_SPARSIFY (solfec, threshold | minarea, mindist)
\end_layout

\begin_layout Standard
This routine modifies contact filtering (sparsification) behaviour.
 Generally speaking, some contact points are filtered out in order to avoid
 unnecessary dense contact point clusters.
 If a pair of bodies is connected by two or more contact points, one of
 the points generated by topologically adjacent entities (elements, convices)
 will be removed (sparsified) if the ratio of contact areas of is smaller
 than the prescribed threshold (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Contact-sparsification"

\end_inset

).
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
threshold
\series default
 - sparsification threshold (default: 0.01) from within the interval [0,
 1].
 Zero corresponds to the lack of sparsification.
\end_layout

\begin_layout Itemize

\series bold
minarea
\series default
 - minimal contact area (default: 0.0).
 Contact points with area smaller then 
\series bold
minarea
\series default
 are dropped.
\end_layout

\begin_layout Itemize

\series bold
mindist
\series default
 - minimal distance between distinct contact points (default: GEOMETRIC_EPSILON).
\end_layout

\begin_layout Subsection*
LOCDYN_DUMP (solfec, path)
\end_layout

\begin_layout Standard
This routine dumps into a file the most recent state of local dynamics.
 It is meant for debugging and test purposes, e.g.
 comparing local dynamics between runs on various processor counts.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - Solfec object
\end_layout

\begin_layout Itemize

\series bold
path
\series default
 - file path
\end_layout

\begin_layout Subsection*
obj = PARTITION (body, parts)
\end_layout

\begin_layout Standard
This routine partitions a finite element body into parts glued by compatibility
 constraints.
 This allows to improve parallel scalability of simulations with large FE
 meshes.
 Metis 
\begin_inset CommandInset citation
LatexCommand cite
key "Metis"

\end_inset

 is employed as the partitioner.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - list of bodies obtained as a result of partitioning.
 If the label of an input body was 'BOD', then the partitioned bodies have
 labels 'BOD_PART1', 'BOD_PART2', etc.
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 (emptied) - a finite element body (cannot have 
\begin_inset Quotes eld
\end_inset

rough mesh
\begin_inset Quotes erd
\end_inset

).
 After partitioning the input body is removed from the domain and replaced
 by the glued parts.
\end_layout

\begin_layout Itemize

\series bold
parts
\series default
 - number of partitions
\end_layout

\begin_layout Subsection*
obj = OVERLAPPING (obstacles, shapes | not, gap)
\end_layout

\begin_layout Standard
This routine looks for shapes (not) overlapping the obstacles.
\end_layout

\begin_layout Itemize

\series bold
obj
\series default
 - list of shapes (not) ovrelapping the obstacles.
\end_layout

\begin_layout Itemize

\series bold
obstacles
\series default
 - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
\end_layout

\begin_layout Itemize

\series bold
shapes
\series default
 (emptied) - object, collection of objects, or a list 
\emph on
[a, b, c, ...]
\emph default
 of objects of type CONVEX, MESH, SPHERE.
\end_layout

\begin_layout Itemize

\series bold
not
\series default
 - 'NOT' string.
\end_layout

\begin_layout Itemize

\series bold
gap
\series default
 - maximal negative gap.
\end_layout

\begin_layout Subsection*
MBFCP_EXPORT (solfec, path)
\end_layout

\begin_layout Standard
This routine exports Solfec model into the MBFCP problem definition format.
 See http://code.google.com/p/mbfcp/ for details.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - Solfec object
\end_layout

\begin_layout Itemize

\series bold
path
\series default
 - output path
\end_layout

\begin_layout Section
Results access
\end_layout

\begin_layout Standard
Results can be accessed either in the 'READ' mode of a SOLFEC object, or
 in the 'WRITE' mode once some analysis has been run.
\end_layout

\begin_layout Subsection*
value = DURATION (solfec)
\end_layout

\begin_layout Standard
This routine returns the duration of a simulation in SOLFEC's 'READ' mode,
 or 
\series bold
\emph on
solfec.time
\series default
\emph default
 in the 'WRITE' mode.
\end_layout

\begin_layout Itemize

\series bold
value
\series default
 - 
\emph on
(t0, t1)
\emph default
 duration limits of the simulation in 'READ' mode or current 
\emph on
time
\emph default
 in 'WRITE' mode
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Subsection*
FORWARD (solfec, steps)
\end_layout

\begin_layout Standard
This routine steps forward within the simulation output file.
 Ignored in SOLFEC's 'WRITE' mode.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
steps
\series default
 - numbers of steps forward
\end_layout

\begin_layout Subsection*
BACKWARD (solfec, steps)
\end_layout

\begin_layout Standard
This routine steps backward within the simulation output file.
 Ignored in SOLFEC's 'WRITE' mode.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
steps
\series default
 - number of steps backward
\end_layout

\begin_layout Subsection*
SEEK (solfec, time)
\end_layout

\begin_layout Standard
This routine to a specific time within the simulation output file.
 Ignored in SOLFEC's 'WRITE' mode.
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
time
\series default
 - time to start reading at
\end_layout

\begin_layout Subsection*
disp = DISPLACEMENT (body, point)
\end_layout

\begin_layout Standard
This routine outputs the displacement of a referential point.
\end_layout

\begin_layout Itemize

\series bold
disp
\series default
 - 
\emph on
(dx, dy, dz)
\emph default
 tuple storing the displacement
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple storing the referential point
\end_layout

\begin_layout Subsection*
velo = VELOCITY (body, point)
\end_layout

\begin_layout Standard
This routine outputs the velocity of a referential point.
\end_layout

\begin_layout Itemize

\series bold
velo
\series default
 - 
\emph on
(vx, vy, vz)
\emph default
 tuple storing the velocity
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 -
\emph on
 (x, y, z)
\emph default
 tuple storing the referential point
\end_layout

\begin_layout Subsection*
stre = STRESS (body, point)
\end_layout

\begin_layout Standard
This routine outputs the Cauchy stress of a referential point.
\end_layout

\begin_layout Itemize

\series bold
stre
\series default
 - 
\emph on
(sx, sy, sz, sxy, sxz, syz, mises)
\emph default
 tuple storing the Cauchy stress and the von Mises norm of it
\end_layout

\begin_layout Itemize

\series bold
body
\series default
 - BODY object
\end_layout

\begin_layout Itemize

\series bold
point
\series default
 - 
\emph on
(x, y, z)
\emph default
 tuple storing the referential point
\end_layout

\begin_layout Subsection*
ene = ENERGY (solfec | object)
\end_layout

\begin_layout Standard
The routine outputs the value of energy of a specific object.
\end_layout

\begin_layout Itemize

\series bold
ene
\series default
 - 
\emph on
(kinetic, internal, external, contact, friction)
\emph default
 tuple of energy values; 
\emph on
internal
\emph default
 energy corresponds to the work of internal forces, 
\emph on
external
\emph default
 energy corresponds to the work of external forces (including constraint
 reactions), 
\emph on
contact
\emph default
 energy corresponds to the work of normal contact reactions, 
\emph on
friction
\emph default
 energy corresponds to the work of tangential contact reactions
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
object
\series default
 - SOLFEC object, BODY object or a list of BODY objects
\end_layout

\begin_layout Subsection*
tim = TIMING (solfec, kind)
\end_layout

\begin_layout Standard
The routine outputs the value of a specific action timing per time step.
\end_layout

\begin_layout Itemize

\series bold
tim
\series default
 - value of timing
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
kind
\series default
 - this is one of: 'TIMINT' (time integration), 'CONUPD' (constraints update),
 'CONDET' (contact detection), 'LOCDYN' (local dynamics setup), 'CONSOL'
 (constraints solution), 'PARBAL' (parallel load balancing).
 The load balancing timing is non-zero only for parallel runs.
\end_layout

\begin_layout Subsection*
hist = HISTORY (solfec, list, t0, t1 | skip, progress)
\end_layout

\begin_layout Standard
This routine outputs time histories of entities.
\end_layout

\begin_layout Itemize

\series bold
hist
\series default
 - a tuple of list objects storing the histories: 
\emph on
(times, values1, values2, ..., valuesN)
\end_layout

\begin_layout Itemize

\series bold
solfec
\series default
 - SOLFEC object
\end_layout

\begin_layout Itemize

\series bold
list
\series default
 - list of objects 
\emph on
[object1, object2, ..., objectN]
\emph default
 indicating requested values.
 The valid objects are: 
\end_layout

\begin_deeper
\begin_layout Itemize
a tuple 
\emph on
(body, point, entity)
\emph default
 where 
\emph on
body
\emph default
 is a BODY object, 
\emph on
point
\emph default
 is a 
\emph on
(x, y, z)
\emph default
 tuple storing the referential point, and 
\emph on
entity
\emph default
 is one of: 'DX', 'DY', 'DZ' (displacement), 'VX', 'VY', 'VZ' (velocity),
 'SX', 'SY', 'SZ', 'SXY', 'SXZ', 'SYZ' (stress), 'MISES' (von Mises norm
 of stress) 
\end_layout

\begin_layout Itemize
a tuple 
\emph on
(object, kind) 
\emph default
where 
\emph on
object
\emph default
 is a SOLFEC object, a BODY object or a list of BODY objects,
\series bold
 
\series default
and 
\emph on
kind
\emph default
 is a string 'KINETIC', 'INTERNAL', 'EXTERNAL', 'CONTACT', 'FRICTION' and
 it corresponds to the energy kind
\end_layout

\begin_layout Itemize
a string 'TIMINT', 'CONUPD', 'CONDET', 'LOCDYN', 'CONSOL', 'PARBAL' for
 timing histories
\end_layout

\begin_layout Itemize
a string 'STEP' for time step history
\end_layout

\begin_layout Itemize
a string 'CONS', 'BODS' for constraint and body number histories
\end_layout

\begin_layout Itemize
a string 'DELBODS', 'NEWBODS' for deleted and inserted (after time 0) body
 number histories (nonzero only for uncompressed outputs)
\end_layout

\begin_layout Itemize
a string 'GSITERS' (Gauss-Seidel iterations count), 'GSCOLORS' (Gauss-Seidel
 processor colors count), 'GSBOT', 'GSMID', 'GSTOP', 'GSINN' (Gauss-Seidel
 bottom, middle, top and inner set sizes), 'GSINIT' (Gauss-Seidel setup
 time), 'GSRUN' (Gauss-Seidel computations time), 'GSCOM' (Gauss-Seidel
 communication time, except the middle set), 'GSMCOM' (Gauss-Seidel middle
 set communication time); values other than 'GSITERS' are non-zero only
 for parallel runs
\end_layout

\begin_layout Itemize
a string 'MERIT' for the time history of the constraints satisfaction merit
 function
\end_layout

\begin_layout Itemize
a string 'NTITERS' for the NEWTON_SOLVER iterations count
\end_layout

\begin_layout Itemize
a tuple 
\emph on
(object, entity)
\emph default
 or 
\emph on
(object, direction
\emph default
, 
\emph on
pair,
\emph default
 
\emph on
entity)
\emph default
 where 
\emph on
object
\emph default
 is a SOLFEC object, a BODY object or a list of BODY objects, 
\emph on
direction
\emph default
 is a tuple 
\begin_inset Formula $\left(d_{x},d_{y},d_{z}\right)$
\end_inset

 storing a direction (use 
\series bold
\emph on
None
\series default
\emph default
 if the 
\emph on
normal
\emph default
 direction is preferred), 
\emph on
pair
\emph default
 is a tuple (
\emph on
surf1,
\emph default
 
\emph on
surf2)
\emph default
 defining a surface pair (use 
\series bold
\emph on
None
\series default
\emph default
 if no surface pair is preferred), and 
\emph on
entity
\emph default
 is:
\end_layout

\begin_deeper
\begin_layout Itemize
'GAP' for the time history of the minimal contact gap among constraints
 attached to given bodies (negative gap corresponds to the penetration depth)
\end_layout

\begin_layout Itemize
'R' for the time history of the resultant (and average over time step 
\begin_inset Formula $\left[t,t+h\right]$
\end_inset

) constraint reactions along the directions: normal or given by the 
\emph on
direction
\end_layout

\begin_layout Itemize
'U' for the time history of the average constraint velocities along the
 directions: normal or given by the 
\emph on
direction
\end_layout

\begin_layout Itemize
'CR' for time histories like in the 'R' case, but for contact constraints
 only
\end_layout

\begin_layout Itemize
'CU' for time histories like in the 'U' case, but for contact constraints
 only
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
t0
\series default
 - time interval start
\end_layout

\begin_layout Itemize

\series bold
t1
\series default
 - time interval end
\end_layout

\begin_layout Itemize

\series bold
skip
\series default
 - number of steps to skip between two time instants
\end_layout

\begin_layout Itemize

\series bold
progress
\series default
 - 'ON' or 'OFF'; print out a percentage based progress bar (default: 'OFF');
 useful for large output files and slow hard disks
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Tutorials"

\end_inset

Tutorials
\end_layout

\begin_layout Section
Three basic geometric objects
\end_layout

\begin_layout Standard
This example illustrates the three basic geometric objects: CONVEX, MESH
 and SPHERE.
 We are going to construct a simple structure and hit it with a ball.
 Let us first create a horizontal floor.
\end_layout

\begin_layout LyX-Code
w = 10
\end_layout

\begin_layout LyX-Code
l = 10
\end_layout

\begin_layout LyX-Code
h = 1
\end_layout

\begin_layout LyX-Code
floor_vid = 1
\end_layout

\begin_layout LyX-Code
floor_sid = 1
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
floor = HULL ([-w/2, -l/2, -h,
\end_layout

\begin_layout LyX-Code
                w/2, -l/2, -h,
\end_layout

\begin_layout LyX-Code
                w/2,  l/2, -h,
\end_layout

\begin_layout LyX-Code
               -w/2,  l/2, -h,
\end_layout

\begin_layout LyX-Code
               -w/2, -l/2,  0,
\end_layout

\begin_layout LyX-Code
                w/2, -l/2,  0,
\end_layout

\begin_layout LyX-Code
                w/2,  l/2,  0,
\end_layout

\begin_layout LyX-Code
               -w/2,  l/2,  0], floor_vid, floor_sid)
\end_layout

\begin_layout Standard
We simply created a convex hull about eight points.
 This is only a geometric object for the moment.
 It exists only in Python interpreter, but not yet inside of a Solfec model.
 In order to insert it into a model, we need first to create a SOLFEC object,
 a BULK_MATERIAL object, and finally a BODY object having the shape described
 by the 
\emph on
floor
\emph default
.
 Here we go.
\end_layout

\begin_layout LyX-Code
step = 1E-3
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
solfec = SOLFEC ('DYNAMIC', step, 'out/tutorail/three-basic-geometric-objects')
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
bulk = BULK_MATERIAL (solfec,
\end_layout

\begin_layout LyX-Code
                      model = 'KIRCHHOFF',
\end_layout

\begin_layout LyX-Code
                      young = 15E9,s
\end_layout

\begin_layout LyX-Code
                      poisson = 0.3,
\end_layout

\begin_layout LyX-Code
                      density = 2E3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
BODY (solfec, 'OBSTACLE', floor, bulk)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Note, that the floor is simply an obstacle - it does not move.
 Before creating the floor body we had to create a SOLFEC object.
 This object gather all necessary data for an individual simulation.
 In our case this will be a dynamic simulation, pursued with the time step
 at least as small as the specified one.
 The time step can be automatically decreased during a simulation due to
 stability requirements.
 The result files of this tutorial will be written to the specified path
 - relative to from there the 'solfec' command was involved.
 Once a body has been inserted into a model, we can view the effect as follows
\end_layout

\begin_layout LyX-Code
> ./solfec -v inp/tutorial/three-basic-geometric-objects.py
\end_layout

\begin_layout Standard
This will create a Solfec viewer, which should result in the following picture
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/three-basic-1.jpg
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
Le us now construct a stack made of two bodies.
 The first one comprises four juxtaposed convex objects.
\end_layout

\begin_layout LyX-Code
a = 2
\end_layout

\begin_layout LyX-Code
b = 2
\end_layout

\begin_layout LyX-Code
c = 2
\end_layout

\begin_layout LyX-Code
brick_vid = 2
\end_layout

\begin_layout LyX-Code
brick_sid = 2
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
brick = CONVEX ([0, 0, 0,
\end_layout

\begin_layout LyX-Code
                 a/2, 0, 0,
\end_layout

\begin_layout LyX-Code
                 a/2, b/2, 0,
\end_layout

\begin_layout LyX-Code
                 0, b/2, 0,
\end_layout

\begin_layout LyX-Code
                 0, 0, c/2,
\end_layout

\begin_layout LyX-Code
                 a/2, 0, c/2,
\end_layout

\begin_layout LyX-Code
                 a/2, b/2, c/2,
\end_layout

\begin_layout LyX-Code
                 0, b/2, c/2],
\end_layout

\begin_layout LyX-Code
                [4, 0, 3, 2, 1, brick_sid,
\end_layout

\begin_layout LyX-Code
                 4, 1, 2, 6, 5, brick_sid,
\end_layout

\begin_layout LyX-Code
                 4, 2, 3, 7, 6, brick_sid,
\end_layout

\begin_layout LyX-Code
                 4, 3, 0, 4, 7, brick_sid,
\end_layout

\begin_layout LyX-Code
                 4, 0, 1, 5, 4, brick_sid,
\end_layout

\begin_layout LyX-Code
                 4, 4, 5, 6, 7, brick_sid], brick_vid)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
b1 = COPY (brick)
\end_layout

\begin_layout LyX-Code
b2 = TRANSLATE (COPY (brick), (a, 0, 0))
\end_layout

\begin_layout LyX-Code
b3 = TRANSLATE (COPY (brick), (0, b, 0))
\end_layout

\begin_layout LyX-Code
b4 = TRANSLATE (COPY (brick), (a, b, 0))
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
shape = [b1, b2, b3, b4]
\end_layout

\begin_layout LyX-Code
TRANSLATE (shape, (-a, -b, 0))
\end_layout

\begin_layout LyX-Code
BODY (solfec, 'RIGID', shape, bulk)
\end_layout

\begin_layout Standard
Note, that a base 
\emph on
brick
\emph default
 was created first.
 Then this brick was copied and manipulated into four different objects:
 
\emph on
b1,b2, ..., b4
\emph default
.
 The list of those objects was passed as a shape when creating the first
 rigid body.
 The second body will be pseudo-rigid and will have its shape defined by
 a mesh.
\end_layout

\begin_layout LyX-Code
nodes = [-1.0, -1.0, 0.0,
\end_layout

\begin_layout LyX-Code
          1.0, -1.0, 0.0,
\end_layout

\begin_layout LyX-Code
          1.0,  1.0, 0.0,
\end_layout

\begin_layout LyX-Code
         -1.0,  1.0, 0.0,
\end_layout

\begin_layout LyX-Code
         -1.0, -1.0, 2.0,
\end_layout

\begin_layout LyX-Code
          1.0, -1.0, 2.0,
\end_layout

\begin_layout LyX-Code
          1.0,  1.0, 1.0,
\end_layout

\begin_layout LyX-Code
         -1.0,  1.0, 1.0]
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
mesh = HEX (nodes, 2, 3, 2, 3, [3, 3, 3, 3, 3, 3], dy = [1, 1, 2])
\end_layout

\begin_layout LyX-Code
TRANSLATE (mesh, (0, 0, c))
\end_layout

\begin_layout LyX-Code
BODY (solfec, 'PSEUDO_RIGID', mesh, bulk) 
\end_layout

\begin_layout Standard
The hexahedral mesh is spanned on eight nodes and has an inclined shape
 due to z level slope.
 Note, that we have specified the 
\begin_inset Quotes eld
\end_inset

dy
\begin_inset Quotes erd
\end_inset

 argument of the HEX command, so to illustrate non-uniform meshing along
 one of the directions.
 The mesh is translated to rest on top of the previous body.
 Then a pseudo-rigid body is created.
 Now, let us create the sphere.
\end_layout

\begin_layout LyX-Code
sphere = SPHERE ((0, 0, 5), 1, 1, 1)
\end_layout

\begin_layout LyX-Code
body = BODY (solfec, 'RIGID', sphere, bulk)
\end_layout

\begin_layout LyX-Code
INITIAL_VELOCITY (body, (0, 0, -10), (0, 0, 0)) 
\end_layout

\begin_layout Standard
When creating the rigid body corresponding to the sphere, we have now retrieved
 the 
\emph on
body
\emph default
 object.
 It is needed in order to prescribe the initial velocity.
 The sphere has the initial linear velocity 
\begin_inset Formula $v_{z}=-10$
\end_inset

 m/s.
 Let us have a look at the model so far.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/three-basic-2.jpg
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
Now, in order to be able to control contact behaviour, we need to define
 a surface material.
 This will be a default material, hence we shall not specify a surface pairing
 (int this example surface identifiers are not used).
 Whenever a contact is detected, the following Signorini-Coulomb model is
 employed
\end_layout

\begin_layout LyX-Code
SURFACE_MATERIAL (solfec, model = 'SIGNORINI_COULOMB',
\end_layout

\begin_layout LyX-Code
                  friction = 0.5, restitution = 0.0)
\end_layout

\begin_layout Standard
It will be also of use to apply some gravity loading.
\end_layout

\begin_layout LyX-Code
GRAVITY (solfec, (0, 0, -10))
\end_layout

\begin_layout Standard
Before running the actual simulation, it remains to create a solver object.
 We use the Gauss-Seidel solver here.
\end_layout

\begin_layout LyX-Code
gs = GAUSS_SEIDEL_SOLVER (1E-3, 1000)
\end_layout

\begin_layout Standard
The relative constraint reaction accuracy was set to 1E-3, while the maximal
 the maximal number of iterations is 1000.
 It remains to run the simulation.
\end_layout

\begin_layout LyX-Code
RUN (solfec, gs, 1.0)
\end_layout

\begin_layout Standard
And then actually run 
\emph on
solfec
\emph default
 from the command line
\end_layout

\begin_layout LyX-Code
./solfec inp/tutorial/three-basic-geometric-objects.py
\end_layout

\begin_layout Standard
One second of the simulation was computed.
 Let us have a look at the displacement along z at the end of this time.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/three-basic-3.jpg
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Section
Ball impact
\end_layout

\begin_layout Standard
This example illustrates using multiple SOLFEC objects, application of the
 PENALTY_SOLVER, and using HISTORY to retrieve and then plot time histories.
 First we define a Python function that will create a model of ball impacting
 a plate for a specific set of parameters.
\end_layout

\begin_layout LyX-Code
def ball_impact (step, stop, spring_value, dashpot_value, output):
\end_layout

\begin_layout LyX-Code
  w = 2
\end_layout

\begin_layout LyX-Code
  l = 2
\end_layout

\begin_layout LyX-Code
  h = 1
\end_layout

\begin_layout LyX-Code
  floor_vid = 1
\end_layout

\begin_layout LyX-Code
  floor_sid = 1
\end_layout

\begin_layout LyX-Code
  floor = HULL ([-w/2, -l/2, -h,
\end_layout

\begin_layout LyX-Code
                  w/2, -l/2, -h,
\end_layout

\begin_layout LyX-Code
                  w/2, l/2, -h,
\end_layout

\begin_layout LyX-Code
                 -w/2, l/2, -h,
\end_layout

\begin_layout LyX-Code
                 -w/2, -l/2, 0,
\end_layout

\begin_layout LyX-Code
                  w/2, -l/2, 0,
\end_layout

\begin_layout LyX-Code
                  w/2, l/2, 0,
\end_layout

\begin_layout LyX-Code
                 -w/2, l/2, 0], floor_vid, floor_sid)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  solfec = SOLFEC ('DYNAMIC', step, output)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  bulk = BULK_MATERIAL (solfec, model = 'KIRCHHOFF',
\end_layout

\begin_layout LyX-Code
                        young = 15E9, poisson = 0.3, density = 2E3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
  BODY (solfec, 'OBSTACLE', floor, bulk)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  sphere = SPHERE ((0, 0, 1.0), 1, 1, 1)
\end_layout

\begin_layout LyX-Code
  body = BODY (solfec, 'RIGID', sphere, bulk)
\end_layout

\begin_layout LyX-Code
  INITIAL_VELOCITY (body, (0, 0, -5), (0, 0, 0))
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  SURFACE_MATERIAL (solfec, model = 'SPRING_DASHPOT', friction = 0.0,
\end_layout

\begin_layout LyX-Code
                    spring = spring_value, dashpot = dashpot_value)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  GRAVITY (solfec, (0, 0, -10))
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  xs = PENALTY_SOLVER ()
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  RUN (solfec, xs, stop)
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  return solfec
\end_layout

\begin_layout Standard
The above code is similar to the previous example.
 Here though the complete model is created inside of a Python function called
 
\emph on
ball_impact
\emph default
.
 By itself this will not run any simulation - this function needs to be
 called from the main module of the input file (we remind that Python uses
 indentation to decide upon code blocking - in our case no indentation indicates
 the main module).
 Above the 'SPRING_DASHPOT' material model is used for the contact interface.
 The parameters of the spring and damper are passed as arguments of the
 
\emph on
ball_impact
\emph default
 function.
 It should be noted, that the SOLFEC object is returned from the routine.
 Now, here is the main module
\end_layout

\begin_layout LyX-Code
step = 1E-3
\end_layout

\begin_layout LyX-Code
stop = 2.0
\end_layout

\begin_layout LyX-Code
spring = 1E+9
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
sol1 = ball_impact (step, stop, spring, 0E0, 'out/tutorial/ball-impact-1')
\end_layout

\begin_layout LyX-Code
sol2 = ball_impact (step, stop, spring, 1E6, 'out/tutorial/ball-impact-2')
\end_layout

\begin_layout LyX-Code
sol3 = ball_impact (step, stop, spring, 1E7, 'out/tutorial/ball-impact-3')
\end_layout

\begin_layout Standard
We simply run three different simulations for three values of the 
\begin_inset Formula $dashpot$
\end_inset

 parameter.
 We can now view the three models by typing
\end_layout

\begin_layout LyX-Code
./solfec -v ./inp/tutorial/ball-impact.py
\end_layout

\begin_layout Standard
The viewer allows change the current model by using '<' and '>' keyboard
 shortcuts, or using the right-mouse click for the drop-down menu and then
 selecting 
\emph on
menu: domain: previous
\emph default
 or 
\emph on
menu: domain: next
\emph default
.
 In this example the three models do not visibly differ.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ball-impact.jpg
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
We could now run each model in the viewer mode (
\emph on
menu: analysis: run
\emph default
), but it will be more useful to plot kinetic energy and compare it for
 all the three values of the 
\begin_inset Formula $dashpot$
\end_inset

 parameter.
 The code below does the job
\end_layout

\begin_layout LyX-Code
if not VIEWER() and sol1.mode == 'READ':
\end_layout

\begin_layout LyX-Code
  import matplotlib.pyplot as plt
\end_layout

\begin_layout LyX-Code
  th = HISTORY (sol1, (sol1, 'KINETIC'), 0, stop)
\end_layout

\begin_layout LyX-Code
  plt.plot (th [0], th [1], lw = 2, label='kin (0)')
\end_layout

\begin_layout LyX-Code
  th = HISTORY (sol2, (sol2, 'KINETIC'), 0, stop)
\end_layout

\begin_layout LyX-Code
  plt.plot (th [0], th [1], lw = 2, label='kin (1E6)')
\end_layout

\begin_layout LyX-Code
  th = HISTORY (sol3, (sol3, 'KINETIC'), 0, stop)
\end_layout

\begin_layout LyX-Code
  plt.plot (th [0], th [1], lw = 2, label='kin (1E7)')
\end_layout

\begin_layout LyX-Code
  plt.axis (xmin = 0, xmax = 2, ymin=-10000, ymax=110000)
\end_layout

\begin_layout LyX-Code
  plt.legend(loc = 'upper right')
\end_layout

\begin_layout LyX-Code
  plt.savefig ('doc/figures/ball-impact.eps')
\end_layout

\begin_layout Standard
First, we check whether Solfec is not run with the 
\emph on
-v
\emph default
 option and whether it is in 'READ' mode.
 This is the case, when after running the complete analysis
\end_layout

\begin_layout LyX-Code
./solfec ./inp/tutorial/ball-impact.py
\end_layout

\begin_layout Standard
we again run
\end_layout

\begin_layout LyX-Code
./solfec ./inp/tutorial/ball-impact.py
\end_layout

\begin_layout Standard
Now, Solfec will find out that the output files in 
\emph on
out/tutorial/ball-impact-(1,2,3)
\emph default
 are present.
 It will open in 'READ' mode.
 In order to create the plot we are going to use the 
\emph on
matplotlib
\emph default
 Python package - please refer to 
\begin_inset CommandInset href
LatexCommand href
target "http://matplotlib.sourceforge.net/index.html"

\end_inset

 in order to learn how to install it.
 We next use the HISTORY command in order to retrieve the time histories
 of the kinetic energy for all three created SOLFEC objects.
 The result in plotted into an EPS file, visible below.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename figures/ball-impact.eps
	lyxscale 50
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
We can see that the 
\begin_inset Formula $dashpot=0$
\end_inset

 results in a fully elastic impact (energy conserving behaviour), 
\begin_inset Formula $dahspot=1E6$
\end_inset

 introduces some fractional energy restitution after impacts, while 
\begin_inset Formula $dashpot=1E7$
\end_inset

 results in a nearly plastic impact.
\end_layout

\begin_layout Chapter
Contact points
\end_layout

\begin_layout Section
Contacts from overlaps
\end_layout

\begin_layout Standard
Body shapes are juxtapositions of convex objects (Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:CONVEX"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:MESH"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SPHERE"

\end_inset

).
 A contact point and normal direction result from an overlap of two convex
 objects (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:volint"

\end_inset

).
 This is motivated by two factors.
 Firstly, the point and the normal direction derived from an overlap are
 well defined for nonsmooth geometry.
 Secondly, we wish to use as few contact points as possible, but still be
 able to control the accuracy of contact resolution by mesh refinement.
 A non-positive 
\begin_inset Formula $gap$
\end_inset

 function is suitably derived from such overlap.
 We refer the reader to Chapter 9 of 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008PhD"

\end_inset

 for more details.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/volint.png
	lyxscale 30
	width 65text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:volint"

\end_inset

A contact point and normal direction extracted from an intersection of two
 convex objects.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Contact-sparsification"

\end_inset

Contact sparsification
\end_layout

\begin_layout Standard
Let us have a look at an arch in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:spar-1"

\end_inset

.
 The detail of two bricks shows narrow meshing near the inner and outer
 boundaries.
 This will allow to better reproduce the hinging mechanism of arch collapse.
 A single brick is composed of six elements: the two large middle elements
 and the four narrow inner and outer elements.
 If we now apply contact detection algorithm, all possible volumetric overlaps
 will be detected.
 Because identically meshed bodies are perfectly adjacent to each other
 we shall end up with a clutter of contact points, generated by all of the
 adjacent element volumes.
 This is visible on the left in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:spar-2"

\end_inset

.
 If one would have to generate contact points by hand, they would probably
 look like those on the right in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:spar-2"

\end_inset

.
 A heuristic sparsification algorithm filters out redundant contact points
 (cf.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Contact-sparsification"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
SPARSIFY 
\begin_inset Formula $\left(\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
  for each 
\begin_inset Formula $contact1$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
    for each 
\begin_inset Formula $body$
\end_inset

 adjacent to 
\begin_inset Formula $contact1$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
      for each 
\begin_inset Formula $contact2$
\end_inset

 adjacent to 
\begin_inset Formula $body$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
        if 
\begin_inset Formula $contact1=contact2$
\end_inset

 skip
\end_layout

\begin_layout LyX-Code
        if 
\begin_inset Formula $area\left(contact1\right)<threshold\cdot area\left(contact2\right)$
\end_inset

 and
\end_layout

\begin_layout LyX-Code
           
\begin_inset Formula $topologically\_adjacent\left(contact1,contact2\right)$
\end_inset

 then remove 
\begin_inset Formula $contact1$
\end_inset


\end_layout

\begin_layout LyX-Code
        else if 
\begin_inset Formula $point\left(contact1\right)=point\left(contact2\right)$
\end_inset

 then remove 
\begin_inset Formula $contact1$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "alg:Contact-sparsification"

\end_inset


\lang english
Contact sparsification algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We walk over all contact points and compare each of them with other contacts
 adjacent through common bodies.
 If the area of a contact is a smaller than an area of a topologically adjacent
 neighbouring contact, then we remove it.
 The same happens if the two contact points coincide.
 Topological adjacency of contact points indicates that they have been created
 between the mesh elements that are topologically adjacent.
 We know then, that next to a contact point with a small supporting area
 there is another one with a suitably larger contact area.
 The Solfec command CONTACT_SPARSIFY sets the 
\begin_inset Formula $threshold$
\end_inset

 value (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:util"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /Users/tomek/Dropbox/tkwork/codes/solfec/doc/figures/arch-1.png
	lyxscale 30
	width 62text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "fig:spar-1"

\end_inset


\lang english
An arch and a detail of two bricks.
 Note the narrow meshing near the edge of inner and outer boundaries.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename figures/arch-2.png
	lyxscale 30
	width 62text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "fig:spar-2"

\end_inset


\lang english
A detail of the arch from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:spar-1"

\end_inset

.
 Contact points on the left are not sparsified.
 Contact points on the right are sparsified.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Time-integration"

\end_inset

Time integration
\end_layout

\begin_layout Section
Rigid kinematics
\end_layout

\begin_layout Section
Deformable kinematics
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Materials"

\end_inset

Materials 
\end_layout

\begin_layout Section
Surface materials
\end_layout

\begin_layout Standard
A surface material is assigned to a pairing of surfaces.
 See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:SURFACE_MATERIAL"

\end_inset

 for the input syntax.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Signorini-Coulomb"

\end_inset

Signorini-Coulomb
\end_layout

\begin_layout Standard
The velocity Signorini condition reads
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\bar{U}_{N}\ge0\,\,\, R_{N}\ge0\,\,\,\bar{U}_{N}R_{N}=0\label{eq:sign}\end{equation}

\end_inset

where 
\begin_inset Formula $\bar{U}_{N}=U_{N}^{t+h}+\eta\min\left(0,U_{N}^{t}\right)$
\end_inset

, 
\begin_inset Formula $\eta$
\end_inset

 is the velocity 
\begin_inset Formula $restitution$
\end_inset

 coefficient, 
\begin_inset Formula $U_{N}$
\end_inset

 is the the normal relative velocity, and 
\begin_inset Formula $R_{N}$
\end_inset

 is the normal reaction.
 The normal direction is consistent with the positive gap velocity so that
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:sign"

\end_inset

) states, that any violation of the non-penetration results in a reactive
 force or velocity driving at the penetration-free configuration.
 Using 
\begin_inset Formula $\bar{U}_{N}$
\end_inset

 allows to account for the Newton impact law.
 
\series bold
\color blue
Only 
\emph on
restitution = 0
\emph default
 or 
\emph on
1
\emph default
 is energy consistent
\series default
\color inherit
 
\series bold
\color red
TODO
\series default
\color inherit
 (cf.
 Section 10.5 of 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008PhD"

\end_inset

).
 The Coulomb's friction law reads
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\left\{ \begin{array}{ll}
\left\Vert \mathbf{R}_{T}\right\Vert \le\mu R_{N}\\
\left\Vert \mathbf{R}_{T}\right\Vert <\mu R_{N} & \Rightarrow\mathbf{U}_{T}=\mathbf{0}\\
\left\Vert \mathbf{R}_{T}\right\Vert =\mu R_{N} & \Rightarrow\exists_{\lambda\ge0}\mathbf{U}_{T}=-\lambda\mathbf{R}_{T}\end{array}\right.\label{eq:Coulomb}\end{equation}

\end_inset

A friction force smaller than 
\begin_inset Formula $\mu R_{N}$
\end_inset

 implies sticking, while sliding occurs with the force of value 
\begin_inset Formula $\mu R_{N}$
\end_inset

 and direction opposite to the slip velocity.
 The two laws can expressed in a compact from 
\begin_inset Formula $\mathbf{C}\left(\mathbf{U},\mathbf{R}\right)=\mathbf{0}$
\end_inset

.
 An examples is
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{C}\left(\mathbf{U},\mathbf{R}\right)=\left[\begin{array}{c}
\max\left(\mu d_{N},\left\Vert \mathbf{d}_{T}\right\Vert \right)\mathbf{R}_{T}-\mu\max\left(0,d_{N}\right)\mathbf{d}_{T}\\
R_{N}-\max\left(0,d_{N}\right)\end{array}\right]\label{eq:CR}\end{equation}

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
d_{N}=R_{N}-\rho\bar{U}_{N}\label{eq:dN}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{d}_{T}=\mathbf{R}_{T}-\rho\mathbf{U}_{T}\label{eq:dT}\end{equation}

\end_inset

and 
\begin_inset Formula $\rho>0$
\end_inset

.
 We refer the reader to Chapter 10 of 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008PhD"

\end_inset

 for more details.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Spring-dashpot"

\end_inset

Spring-dashpot
\end_layout

\begin_layout Standard
Let
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
s=spring\mbox{ and }d=dashpot\mbox{ and }g=gap\end{equation}

\end_inset

The normal reaction is computed as follows
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
R_{N}=-s\cdot\frac{g^{t+h}+g^{t}}{2}-d\cdot\frac{U_{N}^{t+h}+U_{N}^{t}}{2}\label{eq:spring-dashpot-1}\end{equation}

\end_inset

where 
\begin_inset Formula $U_{N}$
\end_inset

 is the normal relative velocity.
 Recall, that the gap function is computed for the configuration 
\begin_inset Formula $\mathbf{q}^{t}+\frac{h}{2}\mathbf{u}^{t}$
\end_inset

, so that the gap function value computed during geometrical contact detection
 reads
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
g=g^{t}+\frac{h}{2}U_{N}^{t}\end{equation}

\end_inset

We then have
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
g^{t+h}=g^{t}+\frac{h}{2}\left(U_{N}^{t+h}+U_{N}^{t}\right)=g+\frac{h}{2}U_{N}^{t+h}\end{equation}

\end_inset

and since 
\begin_inset Formula $g^{t}=g-\frac{h}{2}U_{N}^{t}$
\end_inset

 we can estimate
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
R_{N}=-s\cdot\left(g+\frac{h}{4}\left(U_{N}^{t+h}-U_{N}^{t}\right)\right)-\frac{d}{2}\cdot\left(U_{N}^{t+h}+U_{N}^{t}\right)\label{eq:spring-dashpot-2}\end{equation}

\end_inset

We then use the diagonal block of local dynamics
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{U}^{t+h}=\mathbf{B}+\mathbf{W}\mathbf{R}\end{equation}

\end_inset

in order to estimate 
\begin_inset Formula $U_{N}^{t+h}$
\end_inset

 as follows
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
U_{N}^{t+h}=B_{N}+\mathbf{W}_{NT}\mathbf{R}_{T}+W_{NN}R_{N}\end{equation}

\end_inset

where a previous tangential reaction 
\begin_inset Formula $\mathbf{R}_{T}$
\end_inset

 is employed.
 Inserting this it into (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:spring-dashpot-2"

\end_inset

) results in
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\bar{B}_{N}=B_{N}+\mathbf{W}_{NT}\mathbf{R}_{T}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
R_{N}=\left[-s\cdot\left(g+\frac{h}{4}\left(\bar{B}_{N}-U_{N}^{t}\right)\right)-\frac{d}{2}\cdot\left(\bar{B}_{N}+U_{N}^{t}\right)\right]/\left[1+\left(s\cdot\frac{h}{4}+\frac{d}{2}\right)\cdot W_{NN}\right]\label{eq:spring-dashpot-3}\end{equation}

\end_inset

The reason for using the above, rather than the classical 
\begin_inset Formula $R_{N}=-s\cdot g-d\cdot U_{N}^{t}$
\end_inset

 is in an increased stability of the current approach.
 Assuming 
\begin_inset Formula $\mathbf{U}_{T}^{t+h}=0$
\end_inset

 we then estimate the tangential stick reaction
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{R}_{T}=-\mathbf{W}_{TT}^{-1}\left(\mathbf{B}_{T}+\mathbf{W}_{TN}R_{N}\right)\end{equation}

\end_inset

The complete interface law is expressed in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Spring-dashpot"

\end_inset

 (
\begin_inset Formula $\mu$
\end_inset

 refers there to the coefficient of friction).
 We refer the reader to Chapter 7 of 
\begin_inset CommandInset citation
LatexCommand cite
key "Koziara2008PhD"

\end_inset

 for more details on local dynamics.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement b
wide false
sideways false
status open

\begin_layout LyX-Code
SPRING_DASHPOT 
\begin_inset Formula $\left(h,g,s,d,\mu,cohesion,cohesive\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
  
\begin_inset Formula $\bar{B}_{N}=B_{N}+\mathbf{W}_{NT}\mathbf{R}_{T}$
\end_inset


\end_layout

\begin_layout LyX-Code
  
\begin_inset Formula $R_{N}=\left[-s\cdot\left(g+\frac{h}{4}\left(\bar{B}_{N}-U_{N}^{t}\right)\right)-\frac{d}{2}\cdot\left(\bar{B}_{N}+U_{N}^{t}\right)\right]/\left[1+\left(s\cdot\frac{h}{4}+\frac{d}{2}\right)\cdot W_{NN}\right]$
\end_inset

  
\end_layout

\begin_layout LyX-Code
  if not 
\begin_inset Formula $cohesive$
\end_inset

 and 
\begin_inset Formula $R_{N}<0$
\end_inset

 then 
\begin_inset Formula $\mathbf{R}=0$
\end_inset

 return
\end_layout

\begin_layout LyX-Code
  
\begin_inset Formula $\mathbf{R}_{T}=-\mathbf{W}_{TT}^{-1}\left(\mathbf{B}_{T}+\mathbf{W}_{TN}R_{N}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
  if 
\begin_inset Formula $cohesive$
\end_inset

 and 
\begin_inset Formula $R_{N}<-cohesion$
\end_inset

 then 
\begin_inset Formula $cohesive=false$
\end_inset

 and 
\begin_inset Formula $R_{N}=-cohesion$
\end_inset


\end_layout

\begin_layout LyX-Code
  if 
\begin_inset Formula $\left\Vert \mathbf{R}_{T}\right\Vert >\mu\left|R_{N}\right|$
\end_inset

 then
\end_layout

\begin_layout LyX-Code
    
\begin_inset Formula $\mathbf{R}_{T}=\mu R_{N}\mathbf{R}_{T}/\left\Vert \mathbf{R}_{T}\right\Vert $
\end_inset


\end_layout

\begin_layout LyX-Code
    if 
\begin_inset Formula $cohesive$
\end_inset

 then 
\begin_inset Formula $cohesive=false$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "alg:Spring-dashpot"

\end_inset


\lang english
Spring-dashpot reaction calculation.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Bulk materials
\end_layout

\begin_layout Standard
A bulk material is assigned to a volume.
 See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BULK_MATERIAL"

\end_inset

 for the input syntax.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Kirchhoff"

\end_inset

Kirchhoff - Saint Venant
\end_layout

\begin_layout Standard
This is a simple extension of the linearly elastic material to the large
 deformation regime.
 Suitable for large rotation, small strain problems.
 The strain energy function 
\begin_inset Formula $\Psi$
\end_inset

 of the Kirchhoff - Saint Venant materials reads
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\Psi=\frac{1}{4}\left[\mathbf{F}^{T}\mathbf{F}-\mathbf{I}\right]:\mathbf{C}:\left[\mathbf{F}^{T}\mathbf{F}-\mathbf{I}\right]\end{equation}

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
C_{ijkl}=\lambda\delta_{ij}\delta_{kl}+\mu\left[\delta_{ik}\delta_{jl}+\delta_{il}\delta_{jk}\right]\end{equation}

\end_inset

In the above 
\begin_inset Formula $\lambda$
\end_inset

 and 
\begin_inset Formula $\mu$
\end_inset

 are Lam
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
'
\end_layout

\end_inset

e constants, while 
\begin_inset Formula $\delta_{ij}$
\end_inset

 is the Kronecker delta.
 The Lam
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
'
\end_layout

\end_inset

e constants can be expressed in terms of the Young modulus 
\begin_inset Formula $E$
\end_inset

 and the Poisson ratio 
\begin_inset Formula $\nu$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\lambda=\frac{E\nu}{\left(1+\nu\right)\left(1-2\nu\right)}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mu=\frac{E}{2+2\nu}\end{equation}

\end_inset

The first Piola stress tensor is computed as a gradient of the hyperelastic
 potential 
\begin_inset Formula $\Psi$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{P}=\partial_{\mathbf{F}}\Psi\left(\mathbf{F}\right)\label{eq:matlaw}\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{F}$
\end_inset

 is the deformation gradient.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Constraints-accuracy"

\end_inset

Constraints accuracy
\end_layout

\begin_layout Standard
As explained in Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "cha:Introduction"

\end_inset

, at every time step an implicit equation 
\begin_inset Formula $\mathbf{C}\left(\mathbf{R}\right)=\mathbf{0}$
\end_inset

 is solved.
 Ideally, when for some 
\begin_inset Formula $\mathbf{R}$
\end_inset

 there holds 
\begin_inset Formula $\mathbf{C}\left(\mathbf{R}\right)=\mathbf{0}$
\end_inset

 we have an exact solution.
 Of course, in numerical terms this is not possible.
 For very large problems, and especially for problems where the amount of
 constraints exceeds the amount of kinematic freedom, obtaining very accurate
 solutions is hard and often impractical.
 In any case, it is useful to have an accuracy measure that has some physical
 interpretation.
 In order to compute constraints accuracy, we formulate 
\begin_inset Formula $\mathbf{C}\left(\mathbf{R}\right)$
\end_inset

 in terms of velocity (cf.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SC-velo"

\end_inset

 for the Signorini-Coulomb law) and use
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
g\left(\mathbf{R}\right)=\sum_{\alpha}\left\langle \mathbf{W}_{\alpha\alpha}^{-1}\mathbf{C}_{\alpha}\left(\mathbf{R}\right),\mathbf{C}_{\alpha}\left(\mathbf{R}\right)\right\rangle /\sum_{\alpha}\left\langle \mathbf{W}_{\alpha\alpha}^{-1}\mathbf{B}_{\alpha},\mathbf{B}_{\alpha}\right\rangle \label{eq:accuracy}\end{equation}

\end_inset

in order to approximately measure the relative amount of spurious energy,
 due to an inexact satisfaction of constraints.
 The denominator corresponds to the kinetic energy of the relative free
 motion, hence 
\begin_inset Formula $g\left(\mathbf{R}\right)$
\end_inset

 is the ratio of the spurious energy over the nominal amount of the energy
 available at the constraints.
 Since inverting 
\begin_inset Formula $\mathbf{W}$
\end_inset

 would be unpractical or impossible due to singularity, we only use the
 diagonal blocks, which are always positive definite.
 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:SC-velo"

\end_inset

Signorini-Coulomb revisited
\end_layout

\begin_layout Standard
We express the Signorini-Coulomb law defined in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signorini-Coulomb"

\end_inset

 in the form suitable for (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:accuracy"

\end_inset

).
 The friction cone 
\begin_inset Formula $FC_{\alpha}$
\end_inset

 is defined as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
FC_{\alpha}=\left\{ \mathbf{R}_{\alpha}:\left\Vert \mathbf{R}_{\alpha T}\right\Vert \le\mu_{\alpha}R_{\alpha N},R_{\alpha N}\ge0\right\} \end{equation}

\end_inset

where 
\begin_inset Formula $\mu_{\alpha}$
\end_inset

 is the coefficient of friction.
 It has been shown by De Saxc
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
'
\end_layout

\end_inset

e and Feng 
\begin_inset CommandInset citation
LatexCommand citep
key "DeSaxce1998"

\end_inset

, that the Signorini-Coulomb law can be expressed in a compact form
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\begin_inset Formula \begin{equation}
-\left[\begin{array}{c}
\mathbf{U}_{\alpha T}\\
\bar{U}_{\alpha N}+\mu_{\alpha}\left\Vert \mathbf{U}_{\alpha T}\right\Vert \end{array}\right]\in N_{FC_{\alpha}}\left(\mathbf{R}_{\alpha}\right)\label{eq:DSF}\end{equation}

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
where 
\begin_inset Formula $N_{FC_{\alpha}}$
\end_inset

 stands for the normal cone of the set 
\begin_inset Formula $FC_{\alpha}$
\end_inset

.
 For a convex set 
\begin_inset Formula $A$
\end_inset

 the normal cone 
\begin_inset Formula $N_{A}\left(\mathbf{R}\right)$
\end_inset

 at point 
\begin_inset Formula $\mathbf{R}\in A$
\end_inset

 is defined as the set of all vectors 
\begin_inset Formula $\mathbf{V}$
\end_inset

 such that 
\begin_inset Formula $\left\langle \mathbf{V},\mathbf{S}-\mathbf{R}\right\rangle \le0$
\end_inset

 for all 
\begin_inset Formula $\mathbf{S}\in A$
\end_inset

.
 Let 
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{F}\left(\mathbf{R}\right)=\left[\begin{array}{c}
...\\
\mathbf{U}_{\alpha T}\left(\mathbf{R}\right)\\
\bar{U}_{\alpha N}\left(\mathbf{R}\right)+\mu_{\alpha}\left\Vert \mathbf{U}_{\alpha T}\left(\mathbf{R}\right)\right\Vert \\
...\end{array}\right]\label{eq:F}\end{equation}

\end_inset

and
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
FC=\bigcup_{\alpha}FC_{\alpha}\end{equation}

\end_inset

where the dependence 
\begin_inset Formula $\mathbf{U}_{\alpha}\left(\mathbf{R}\right)$
\end_inset

 is defined in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:locdyn"

\end_inset

).
 Formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DSF"

\end_inset

) states, that the frictional contact constraints are satisfied if 
\begin_inset Formula $-\mathbf{F}\left(\mathbf{R}\right)$
\end_inset

 belongs to the normal cone of the friction cone at 
\begin_inset Formula $\mathbf{R}$
\end_inset

.
 Hence
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
-\mathbf{F}\left(\mathbf{R}\right)=\mathbf{R}-\mathbf{F}\left(\mathbf{R}\right)-\mbox{proj}_{FC}\left(\mathbf{R}-\mathbf{F}\left(\mathbf{R}\right)\right)\end{equation}

\end_inset

which can be reduced to the usual projection formula 
\begin_inset Formula $\mathbf{R}=\mbox{proj}_{FC}\left(\mathbf{R}-\mathbf{F}\left(\mathbf{R}\right)\right)$
\end_inset

.
 Let us not do it though, but rather define a vector field
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{m}\left(\mathbf{S}\right)=\mathbf{S}-\mbox{proj}_{FC}\left(\mathbf{S}\right)=\mathbf{n}\left(\mathbf{S}\right)\left\langle \mathbf{n}\left(\mathbf{S}\right),\mathbf{S}\right\rangle \end{equation}

\end_inset

where
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{n}_{\alpha}\left(\mathbf{S}_{\alpha}\right)=\left\{ \begin{array}{lll}
\mathbf{0} & \mbox{if} & \left\Vert \mathbf{S}_{\alpha T}\right\Vert -\mu_{\alpha}S_{\alpha N}\le0\\
\mathbf{S}_{\alpha}/\left\Vert \mathbf{S}_{\alpha}\right\Vert  & \mbox{if} & \mu_{\alpha}\left\Vert \mathbf{S}_{\alpha T}\right\Vert +S_{\alpha N}<0\\
\frac{1}{\sqrt{1+\mu_{\alpha}^{2}}}\left[\begin{array}{c}
\mathbf{S}_{\alpha T}/\left\Vert \mathbf{S}_{\alpha T}\right\Vert \\
-\mu_{\alpha}\end{array}\right] & \mbox{} & \mbox{otherwise}\end{array}\right.\label{eq:n}\end{equation}

\end_inset

We can rewrite (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:DSF"

\end_inset

) as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{C}\left(\mathbf{R}\right)=\mathbf{F}\left(\mathbf{R}\right)+\mathbf{m}\left(\mathbf{R}-\mathbf{F}\left(\mathbf{R}\right)\right)=\mathbf{0}\mbox{ and }\mathbf{R}\in FC\label{eq:C1}\end{equation}

\end_inset

Note, that 
\begin_inset Formula $\mathbf{F}\left(\mathbf{R}\right)$
\end_inset

 is expressed in terms of velocity, and so is 
\begin_inset Formula $\mathbf{C}\left(\mathbf{R}\right)$
\end_inset

.
\end_layout

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Solvers"

\end_inset

Solvers
\end_layout

\begin_layout Standard
Development of solvers for unilateral dynamics is one of the main driving
 forces behind Solfec.
 The two solvers described in Sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Gauss-Seidel-solver"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Penalty-solver"

\end_inset

 are the classical Gauss-Seidel approach of Contact Dynamics and a somewhat
 modified penalty solver of the Discrete Element Method.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Gauss-Seidel-solver"

\end_inset

Gauss-Seidel solver
\end_layout

\begin_layout Standard
The equations of local dynamics (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:locdyn"

\end_inset

) read
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{U}_{\alpha}=\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}\end{equation}

\end_inset

where 
\begin_inset Formula $\mathbf{U}_{\alpha}$
\end_inset

 are relative velocities and 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

 are reactions at constraint points.
 
\begin_inset Formula $\mathbf{U}_{\alpha},\mathbf{R}_{\alpha},\mathbf{B}_{\alpha}$
\end_inset

 are 3-vectors, while 
\begin_inset Formula $\mathbf{W}_{\alpha\beta}$
\end_inset

 are 
\begin_inset Formula $3\times3$
\end_inset

 matrix blocks.
 Each constraint equation can be formulated as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{C}_{\alpha}\left(\mathbf{U}_{\alpha},\mathbf{R}_{\alpha}\right)=\mathbf{0}\end{equation}

\end_inset

or in other words
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
SERIAL_GAUSS_SEIDEL 
\begin_inset Formula $\left(Constraints,\epsilon,\gamma\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1  do
\end_layout

\begin_layout LyX-Code
2    for each 
\begin_inset Formula $\alpha$
\end_inset

 in 
\begin_inset Formula $Constraints$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
3      
\begin_inset Formula $\mathbf{S}_{\alpha}=\mathbf{R}_{\alpha}$
\end_inset


\end_layout

\begin_layout LyX-Code
4      find 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

 such that 
\begin_inset Formula $\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}$
\end_inset


\end_layout

\begin_layout LyX-Code
5                         assuming 
\begin_inset Formula $\mathbf{R}_{\beta}=\mbox{constant}$
\end_inset

 for 
\begin_inset Formula $\beta\ne\alpha$
\end_inset


\end_layout

\begin_layout LyX-Code
6  while 
\begin_inset Formula $\left\Vert \mathbf{S}-\mathbf{R}\right\Vert /\left\Vert \mathbf{R}\right\Vert >\epsilon$
\end_inset

 and 
\begin_inset Formula $g\left(\mathbf{R}\right)>\gamma$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Serial-Gauss-Seidel"

\end_inset

Serial Gauss-Seidel algorithm
\end_layout

\end_inset


\end_layout

\end_inset

Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Serial-Gauss-Seidel"

\end_inset

 is quite simple: diagonal block problems are solved until reaction change
 is small enough.
 The Gauss-Seidel paradigm corresponds to the fact, that the most recent
 off-diagonal reactions are used when solving the diagonal problem.
 Of course, because of that, a perfectly parallel implementation is not
 possible.
 After all, reactions are updated in a sequence.
 We can nevertheless relax the need for sequential processing.
 Perhaps the most scalable Gauss-Seidel approach to date was devised by
 Adams 
\begin_inset CommandInset citation
LatexCommand cite
key "Adams01"

\end_inset

.
 Although originally it was used as a multi-grid smoother, the core idea
 can be as well applied in our context.
 Each processor owes a subset of (internal) constraints 
\begin_inset Formula $Q_{i}$
\end_inset

, where 
\begin_inset Formula $i=1,2,...,n$
\end_inset

 are the processors indices.
 Therefore the local velocity update can be rewritten as
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\mathbf{U}_{\alpha}=\mathbf{B}_{\alpha}+\sum_{\beta\in Q_{i}}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}+\sum_{\beta\notin Q_{i}}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta}\end{equation}

\end_inset

Some of the 
\begin_inset Formula $\mathbf{W}_{\alpha\beta}$
\end_inset

 blocks and reactions 
\begin_inset Formula $\mathbf{R}_{\beta}$
\end_inset

 correspond to the (external) constraints stored on other processors (
\begin_inset Formula $\beta\notin Q_{i}$
\end_inset

).
 Let us denote the set of corresponding reaction indices by 
\begin_inset Formula $P_{i}$
\end_inset

.
 That is 
\begin_inset Formula \begin{equation}
P_{i}=\left\{ \beta:\exists\mathbf{W}_{\alpha\beta}\ne\mathbf{0}\mbox{ and }\alpha\in Q_{i}\mbox{ and }\beta\notin Q_{i}\right\} \end{equation}

\end_inset

For each 
\begin_inset Formula $\beta\in P_{i}$
\end_inset

 we know an index of processor 
\begin_inset Formula $cpu\left(\beta\right)$
\end_inset

 storing the constraint with index 
\begin_inset Formula $\beta$
\end_inset

.
 For processor 
\begin_inset Formula $i$
\end_inset

 we can then define a set of adjacent processors as follows
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
adj\left(i\right)=\left\{ cpu\left(\beta\right):\beta\in P_{i}\right\} \end{equation}

\end_inset

When updating reactions, a processor needs to communicate only with other
 adjacent processors.
 We are going to optimise a pattern of this communication by 
\emph on
coloring
\emph default
 the processors.
 We shall then assign to each processor a color, such that no two adjacent
 processors have the same color.
 A simple coloring method is summarised in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Simple-processor-coloring"

\end_inset

.
 We try to assign as few colors as possible.
 We then split the index sets 
\begin_inset Formula $Q_{i}$
\end_inset

 as follows
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
COLOR 
\begin_inset Formula $\left(\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1  for 
\begin_inset Formula $i$
\end_inset


\begin_inset Formula $=1,...,n$
\end_inset

 do 
\begin_inset Formula $color\left[i\right]=0$
\end_inset


\end_layout

\begin_layout LyX-Code
2  for 
\begin_inset Formula $i$
\end_inset


\begin_inset Formula $=1,...,n$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
3    do
\end_layout

\begin_layout LyX-Code
4      
\begin_inset Formula $color\left[i\right]=color\left[i\right]+1$
\end_inset


\end_layout

\begin_layout LyX-Code
5    while for any 
\begin_inset Formula $j\in adj\left(i\right)$
\end_inset

 there holds 
\begin_inset Formula $color\left[i\right]=color\left[j\right]$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "alg:Simple-processor-coloring"

\end_inset


\lang english
Simple processor coloring.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Top_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge color\left[cpu\left(\beta\right)\right]<color\left[i\right]\right\} \end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Bottom_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge color\left[cpu\left(\beta\right)\right]>color\left[i\right]\right\} \end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Middle_{i}=\left\{ \alpha:\forall\mathbf{W}_{\alpha\beta}:\beta\in P_{i}\wedge\alpha\notin Top_{i}\cup Bottom_{i}\right\} \end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Inner_{i}=Q_{i}\setminus\left\{ Top_{i}\cup Bottom_{i}\cup Middle_{i}\right\} \end{equation}

\end_inset

The top constraints require communication only with processors of lower
 colors.
 The bottom constraints require communication only with processors of higher
 colors.
 The middle constraints require communication with either.
 The inner constraints require no communication.
 The inner reactions are further split in two sets
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
Inner_{i}=Inner1_{i}\cup Inner2_{i}\end{equation}

\end_inset

so that
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\left|Bottom_{i}\right|+\left|Inner2_{i}\right|=\left|Top_{i}\right|+\left|Inner1_{i}\right|\label{eq:gsbalcnd}\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout LyX-Code
SWEEP 
\begin_inset Formula $\left(Set\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1  for each 
\begin_inset Formula $\alpha\in Set$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
2    find 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

 such that 
\begin_inset Formula $\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}$
\end_inset


\end_layout

\begin_layout LyX-Code
3                       assuming 
\begin_inset Formula $\mathbf{R}_{\beta}=\mbox{constant}$
\end_inset

 for 
\begin_inset Formula $\beta\ne\alpha$
\end_inset


\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
LOOP 
\begin_inset Formula $\left(Set\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1  descending sort of 
\begin_inset Formula $\alpha\in Set$
\end_inset

 based on 
\begin_inset Formula $\max\left(color\left[cpu\left(\beta\right)\right]\right)$
\end_inset

 where 
\begin_inset Formula $\exists\mathbf{W}_{\alpha\beta}$
\end_inset


\end_layout

\begin_layout LyX-Code
2  for each ordered 
\begin_inset Formula $\alpha$
\end_inset

 in 
\begin_inset Formula $Set$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
3    for each 
\begin_inset Formula $\beta$
\end_inset

 such that 
\begin_inset Formula $\exists\mathbf{W}_{\alpha\beta}$
\end_inset

 and 
\begin_inset Formula $color\left[cpu\left(\alpha\right)\right]<color\left[cpu\left(\beta\right)\right]$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
4      if not received 
\begin_inset Formula $\left(\mathbf{R}_{\beta}\right)$
\end_inset

 then receive 
\begin_inset Formula $\left(\mathbf{R}_{\beta}\right)$
\end_inset

 
\end_layout

\begin_layout LyX-Code
5    find 
\begin_inset Formula $\mathbf{R}_{\alpha}$
\end_inset

 such that 
\begin_inset Formula $\mathbf{C}_{\alpha}\left(\mathbf{B}_{\alpha}+\sum_{\beta}\mathbf{W}_{\alpha\beta}\mathbf{R}_{\beta},\mathbf{R}_{\alpha}\right)=\mathbf{0}$
\end_inset


\end_layout

\begin_layout LyX-Code
6                       assuming 
\begin_inset Formula $\mathbf{R}_{\beta}=\mbox{constant}$
\end_inset

 for 
\begin_inset Formula $\beta\ne\alpha$
\end_inset


\end_layout

\begin_layout LyX-Code
7    send 
\begin_inset Formula $\left(\mathbf{R}_{\alpha}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
8  receive all remaining 
\begin_inset Formula $\mathbf{R}_{\beta}$
\end_inset


\end_layout

\begin_layout LyX-Code
 
\end_layout

\begin_layout LyX-Code
PARALLEL_GAUSS_SEIDEL 
\begin_inset Formula $\left(\epsilon,\gamma\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1   COLOR 
\begin_inset Formula $\left(\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
2   do
\end_layout

\begin_layout LyX-Code
3     SWEEP 
\begin_inset Formula $\left(Top_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
4     send 
\begin_inset Formula $\left(Top_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
5     SWEEP 
\begin_inset Formula $\left(Inner2_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
6     receive 
\begin_inset Formula $\left(Top_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
7     LOOP 
\begin_inset Formula $\left(Middle_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
8     SWEEP 
\begin_inset Formula $\left(Bottom_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
9     send 
\begin_inset Formula $\left(Bottom_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
10    SWEEP 
\begin_inset Formula $\left(Inner1_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
11    receive 
\begin_inset Formula $\left(Bottom_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
12  while 
\begin_inset Formula $\left\Vert \mathbf{S}-\mathbf{R}\right\Vert /\left\Vert \mathbf{R}\right\Vert >\epsilon$
\end_inset

 and 
\begin_inset Formula $g\left(\mathbf{R}\right)>\gamma$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Parallel-Gauss-Seidel"

\end_inset

Parallel Gauss-Seidel algorithm.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parallel Gauss-Seidel scheme is summarised in Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Parallel-Gauss-Seidel"

\end_inset

.
 The presented version is simplified in the respect, that alternate forward
 and backward runs are not accounted for (in terms of constraints ordering).
 We first process the 
\begin_inset Formula $Top_{i}$
\end_inset

 set: a single sweep over the corresponding diagonal block problems is performed
 in line 3.
 Then we send the computed top reactions to the processors with lower colors.
 We try to overlap communication and computation, hence we sweep over the
 
\begin_inset Formula $Inner2_{i}$
\end_inset

 set (line 5) while sending.
 We then receive the top reactions.
 It should be noted that all communication is asynchronous - we only wait
 to receive reactions immediately necessary for computations.
 In line 7 we enter the loop processing the 
\begin_inset Formula $Middle_{i}$
\end_inset

 set.
 This is the location of the computational bottleneck.
 Middle nodes communicate with processors of higher and lower colors and
 hence, they need to be processed in a sequence.
 The sequential processing is still relaxed by using processor coloring.
 In the LOOP algorithm we first sort the constraints according to the descending
 order of maximal colors of their adjacent processors (line 1).
 We then maintain this ordering while processing constraints.
 As the top reactions were already sent, some of the constraints from the
 middle set will have their external reactions from higher colors fully
 updated.
 These will be processed first in line 5 of LOOP and then sent to lower
 and higher (by color) processors in line 7.
 This way some processors with lower colors will have their higher color
 off-diagonal reactions of middle set constraints fully updated and they
 will proceed next.
 And so on.
 At the end (line 8), we need to receive all remaining reactions that have
 been sent in line 7 of LOOP.
 Coming back to PARALLEL_GAUSS_SEIDEL, after the bottleneck of the LOOP,
 in lines 8-11 we process the 
\begin_inset Formula $Bottom_{i}$
\end_inset

 and 
\begin_inset Formula $Inner1_{i}$
\end_inset

 sets in the same way as we did with the 
\begin_inset Formula $Top_{i}$
\end_inset

 and 
\begin_inset Formula $Inner2_{i}$
\end_inset

 sets.
 The condition (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:gsbalcnd"

\end_inset

) attempts to balance the amount of computations needed to hide the communicatio
n (e.g.
 the larger the 
\begin_inset Formula $Top_{i}$
\end_inset

 set is, the larger the 
\begin_inset Formula $Inner2_{i}$
\end_inset

 set becomes).
 It should be noted that the convergence criterion in line 12 is global
 across all processors.
 
\end_layout

\begin_layout Standard
In Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GAUSS_SEIDEL_SOLVER"

\end_inset

 several variants of the parallel algorithm are listed.
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Parallel-Gauss-Seidel"

\end_inset

 corresponds to the FULL variant.
 We might like to relax the bottleneck of LOOP in line 7 of Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Parallel-Gauss-Seidel"

\end_inset

 by replacing it with
\end_layout

\begin_layout LyX-Code
7.1   SWEEP 
\begin_inset Formula $\left(Middle_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
7.2   send 
\begin_inset Formula $\left(Middle_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
7.3   receive 
\begin_inset Formula $\left(Middle_{i}\right)$
\end_inset


\end_layout

\begin_layout Standard
\noindent
so that the middle nodes are processed in an inconsistent manner: the off-proces
sor information corresponds to the previous iteration (just like in the
 Jacobi method).
 Usually the 
\begin_inset Formula $Middle_{i}$
\end_inset

 sets are small and hence this inconsistency does not have to lead to divergence
 (especially for deformable kinematics, where constraint interactions are
 weak, while 
\begin_inset Formula $\mathbf{W}$
\end_inset

 is diagonally dominant).
 This is the MIDDLE_JACOBI variant of the algorithm.
 The last variant corresponds to a rather gross inconsistency: something
 usually called 
\begin_inset Quotes eld
\end_inset

a processor Gauss-Seidel method
\begin_inset Quotes erd
\end_inset

.
 Let us define the set
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
All_{i}=Top_{i}\cup Bottom_{i}\cup Middle_{i}\cup Inner_{i}\end{equation}

\end_inset

In this case, lines 3-11 of PARALLEL_GAUSS_SEIDEL from Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Parallel-Gauss-Seidel"

\end_inset

 need to be replaced with
\end_layout

\begin_layout LyX-Code
3   SWEEP 
\begin_inset Formula $\left(All_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
4   send 
\begin_inset Formula $\left(All_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
5   receive 
\begin_inset Formula $\left(All_{i}\right)$
\end_inset


\end_layout

\begin_layout Standard
\noindent
Although this kind of approach does work as a multi-grid smoother, it has
 little use in our context.
 Nevertheless, we use for illustration sake and name the BOUNDARY_JACOBI.
 The final and crudest variant of the solver is called SIMPLIFIED.
 This variant is devised with soft deformable models in mind.
 We split constraints into 
\begin_inset Formula $Contacts_{i}$
\end_inset

 and 
\begin_inset Formula $Others_{i}$
\end_inset

, hence we separate contact constraints from bilateral ones.
 We then do the following
\end_layout

\begin_layout LyX-Code
1   SWEEP 
\begin_inset Formula $\left(Contacts_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
2   send 
\begin_inset Formula $\left(Contacts_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
3   receive 
\begin_inset Formula $\left(Contacts_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
4   do
\end_layout

\begin_layout LyX-Code
5     SWEEP 
\begin_inset Formula $\left(Others_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
6   while 
\begin_inset Formula $\left\Vert \mathbf{S}-\mathbf{R}\right\Vert /\left\Vert \mathbf{R}\right\Vert >\epsilon$
\end_inset

 and 
\begin_inset Formula $g\left(\mathbf{R}\right)>\gamma$
\end_inset


\end_layout

\begin_layout Standard
A single sweep over contacts is followed by the Gauss-Seidel loop over bilateral
 constraints.
 This is possible because bilateral constraints migrate together with bodies
 and hence are local to the processor (an exception is for the rigid link
 constraint, for which this approach might break down 
\series bold
\color red
TODO
\series default
\color inherit
).
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Penalty-solver"

\end_inset

Penalty solver
\end_layout

\begin_layout Standard
The penalty solver is quite straightforward.
 On each processor we split the constraints into 
\begin_inset Formula $Contacts_{i}$
\end_inset

 and 
\begin_inset Formula $Others_{i}$
\end_inset

, hence we separate contact constraints from bilateral ones.
 We then update the contacts using the spring-dashpot model and calculate
 reactions of bilateral constraints using a local Gauss-Seidel solver.
 We use the Gauss-Seidel approach for non-contacts because in this case
 it is quite fast, while it avoids issues related to penalisation of bilateral
 constraints.
 Using Gauss-Seidel is possible because bilateral constraints migrate together
 with bodies and hence are local to the processor (an exception is for the
 rigid link constraint, for which this approach might break down 
\series bold
\color red
TODO
\series default
\color inherit
).
 Algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Parallel-explicit-solver"

\end_inset

 summarises the method.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout LyX-Code
PARALLEL_PENALTY_SOLVER 
\begin_inset Formula $\left(\epsilon\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
1  for all 
\begin_inset Formula $\alpha$
\end_inset

 in 
\begin_inset Formula $Contacts_{i}$
\end_inset

 do
\end_layout

\begin_layout LyX-Code
2    SPRING_DASHPOT 
\begin_inset Formula $\left(h,gap_{\alpha},spring_{\alpha},dashpot_{\alpha},friction_{\alpha},cohesion_{\alpha},cohesive_{\alpha}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
3  send 
\begin_inset Formula $\left(Contacts_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
4  receive 
\begin_inset Formula $\left(Contacts_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
5  SERIAL_GAUSS_SEIDEL 
\begin_inset Formula $\left(Others_{i},\epsilon\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
6  send 
\begin_inset Formula $\left(Others_{i}\right)$
\end_inset


\end_layout

\begin_layout LyX-Code
7  receive 
\begin_inset Formula $\left(Others_{i}\right)$
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout

\lang british
\begin_inset CommandInset label
LatexCommand label
name "alg:Parallel-explicit-solver"

\end_inset


\lang english
Parallel penalty solver.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/Users/tomek/Dropbox/tkwork/bibs/rigid-bodies,/Users/tomek/Dropbox/tkwork/bibs/contact-related,/Users/tomek/Dropbox/tkwork/bibs/phd,/Users/tomek/Dropbox/tkwork/bibs/time-stepping,/Users/tomek/Dropbox/tkwork/bibs/algo"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
