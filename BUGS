Sweep algorithms get stuck when run on many cpus (e.g. -np 8 with mpi1.py and N=20)
GUESS: insertion sort is run on badly ordered sets with O(n ^2) complexity
------------------------------------------------------------------------------------
Note that during W assembly when using MX_Matmat (coef, ...)
the assembly takes much longer than when scaling after (like now).
Investigate why!
---------------------------------------------------------------------------
SET_Delete_Node and MAP_Delete_Node do not seem to be correct
in terms of returning the next node in turn (valgrinded out)
--------------------------------------------------------------------------------
Note, the difference in sending boundary constraint bases between revisions
301 and 302:

Instead of SEND (con->base+6, 3) and localbase (...) on receive, we now
(like in an old version) SEND (con->base, 9) and receive accordingly.

This seems to fix the issue of premature overlap in simplified core tests,
and is likely caused by a numerical noise introduced by recreating bases from
normal directions.

Now, the problem can be really down to base recreation noise (there is an 'if' in the 'localbase' routine), BUT,
it can also be down to communication routines error (outputing rubbish normals), now masked by sending longer messages.

Think of a way of testing and deciding on the origin of this problem. Surely,
more through testing of cummunication routines would be of use (comtest).

After all we have increased communication by some 48 bytes per contact now again.
---------------------------------------------------------------------------------------
HASH3D detects much too few constraints (e.g. for inp/puzzle.py ~1000 from 5666)
-----------------------------------------------------------------------------------
Diagonal DE_SAXCE_FENG solver performs poorely on simple-small-prb-gs example
even for one brick. Investigate!
---------------------------------------------------------------------------------------
Self-contact handling is incorrect: inp/selfcontact.py
(Algebraic stuff has been fixed; Now this is the matter of contact detection;
 In the mentioned example, near contradictory contact points are detected)
---------------------------------------------------------------------------------------
Merit function gets stuck at the beginning the Newton craddle example
